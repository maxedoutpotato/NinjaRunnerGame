<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ninja Runner</title>

    <!-- Open Graph Meta Tags for Link Previews -->
    <meta property="og:title" content="Ninja Runner Game" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://maxedoutpotato.github.io/NinjaRunnerGame/" />
    <meta property="og:image" content="https://maxedoutpotato.github.io/NinjaRunnerGame/Assets/Preview/preview.png" />
    <meta property="og:description" content="A fast-paced 2D endless runner. Jump and crouch to dodge obstacles and collect bonuses in this challenging ninja adventure!" />

    <!-- SEO and Social Sharing Meta Tags -->
    <meta name="keywords" content="ninja, runner, endless runner, javascript game, html5 game, canvas game, indie game, 2d game, gamedev">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Ninja Runner Game">
    <meta name="twitter:description" content="A fast-paced 2D endless runner. Jump and crouch to dodge obstacles and collect bonuses!">
    <meta name="twitter:image" content="https://maxedoutpotato.github.io/NinjaRunnerGame/Assets/Preview/preview.png">


    <style>
        /* Define the custom font */
        @font-face {
            font-family: 'Amanojaku';
            src: url('https://maxedoutpotato.github.io/NinjaRunnerGame/Amanojaku%20Demo.otf') format('opentype');
        }

        /* Basic styling to center the game and make it look clean */
        body, html {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
            margin: 0;
            background-color: #1a1a1a; /* Darker grey for letterboxing */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            flex-direction: column;
            overflow: hidden; /* Prevent scrolling on mobile */
        }
        canvas {
            background-color: #f0f0f0;
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            /* This makes the canvas responsive */
            width: 100%;
            height: 100%;
            object-fit: contain;
            max-height: 100vh;
            max-width: 100vw;
            cursor: default;
        }
        #rotate-message {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: #282c34;
            color: white;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 24px;
            z-index: 100;
        }
        @media (orientation: portrait) {
            #rotate-message {
                display: flex;
            }
            #gameCanvas {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="rotate-message">
        <canvas id="rotateCanvas" width="250" height="500"></canvas>
    </div>
    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <script>
        // --- Canvas and Context Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const rotateCanvas = document.getElementById('rotateCanvas');
        const rotateCtx = rotateCanvas.getContext('2d');

        // --- Device Detection ---
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // --- Game Constants ---
        const GRAVITY = 2300;
        const JUMP_STRENGTH = -900;
        const PLAYER_SPRITE_WIDTH = 100;
        const PLAYER_SPRITE_HEIGHT = 100;
        const PLAYER_DRAW_WIDTH = 100;
        const PLAYER_DRAW_HEIGHT = 100;
        const DEBUG_MODE = false; // Set to true to see hitboxes
        
        // --- Physics vs Visuals ---
        const GROUND_HEIGHT_PHYSICS = 68;
        const VISUAL_GROUND_Y_OFFSET = -182;
        const VISUAL_GROUND_HEIGHT = 250;

        // --- Background Visuals ---
        const BG1_Y_POS = -540;
        const BG1_SCALE = 1.75;
        const BG2_Y_POS = -400;
        const BG2_SCALE = 1.3;

        // --- Scenery Visuals ---
        const MOUNTAIN_Y_POS = 40;
        const MOUNTAIN_AVG_SCALE = 0.8;
        const MOUNTAIN_SCALE_VARIANCE = 0.2;

        // --- Foreground Visuals ---
        const GRASS_Y_POS = 235;
        const GRASS_SPEED_MODIFIER = 1.5;
        const GRASS_SCALE = 2;

        // --- Player Effect Visuals ---
        const RUN_CLOUD_OFFSET_X = -70;
        const RUN_CLOUD_OFFSET_Y = 1;
        
        const PLAYER_GROUND_LEVEL = canvas.height - GROUND_HEIGHT_PHYSICS - PLAYER_DRAW_HEIGHT;

        const SHURIKEN_FLYING_HEIGHTS = [
            PLAYER_GROUND_LEVEL + PLAYER_DRAW_HEIGHT - 80,
            PLAYER_GROUND_LEVEL - 25,
            PLAYER_GROUND_LEVEL - 120
        ];

        // --- Game State ---
        let menuState = 'pre-menu'; // 'pre-menu', 'intro', 'loop', 'outro', 'inactive'
        let gameStarted = false;
        let gameOver = false;
        let gameOverFade = 0;
        let gameWon = false;
        let canRestart = false;
        let isRestarting = false; // For fade transition
        let isResetting = false; // For menu transition
        let isRestartButtonAnimating = false;
        let restartFadeAmount = 0;
        let fadeDirection = 1;
        let groundX = 0;
        let bg1X = 0;
        let bg2X = 0;
        let grassX = 0;
        let gameSpeed = 300;
        const speedIncreaseRate = 0.3;
        let obstaclesArray = [];
        let sceneryArray = [];
        let effectsArray = [];
        let score = 0;
        let uiFadeInTimer = 0;
        let floatingScores = [];
        let scoreMilestone = 1;
        let scoreBounceTimer = 0;
        let teleportBounceTimer = 0;
        let teleportCharges = 0;
        let inversionAmount = 0;
        let inversionTarget = 0;
        let lastTime = 0;
        
        let menuFrame = 0;
        let menuFrameTimer = 0;
        let preMenuFrame = 0;
        let preMenuFrameTimer = 0;
        let rotateFrame = 0;
        let rotateFrameTimer = 0;
        
        let touchStartTime = 0;
        let isHoldingTouch = false;
        let audioUnlocked = false;
        let wantsToCrouch = false;
        let isMuted = false;
        let showPreMenuBehindIntro = false;
        let isInfoBoxVisible = false;
        let isShareMenuOpen = false;
        let gameOverTextFade = 1;

        // --- Bonus Spawn Tracking ---
        let bonusSpawns = {
            teleportGold: { '3000': 0, '9000': 0, '15000': 0 },
            bonusPoints: { '3000': 0, '6000': 0, '9000': 0, '12000': 0, '15000': 0, '18000': 0, '21000': 0 }
        };
        const bonusLimits = {
            teleportGold: { '3000': 2, '9000': 1, '15000': 1 },
            bonusPoints: { '3000': 4, '6000': 3, '9000': 2, '12000': 2, '15000': 3, '18000': 2, '21000': 2 }
        };

        // --- Player State ---
        let player = {
            x: 50, y: PLAYER_GROUND_LEVEL, width: PLAYER_DRAW_WIDTH, height: PLAYER_DRAW_HEIGHT,
            velocityY: 0, isJumping: false, isCrouching: false, isTeleporting: false,
            frame: 0, frameTimer: 0, state: 'run',
            hitbox: { offsetX: 20, offsetY: 20, width: 65, height: 40 },
            crouchHitbox: { offsetX: 10, offsetY: 50, width: 70, height: 30 }
        };
        
        // --- UI Button States ---
        let restartButton = {
            x: 0, y: 0, width: 120, height: 120,
            frame: 0, frameTimer: 0, isHovered: false
        };
        let volumeButton = {
            x: 0, y: 0, width: 50, height: 50,
            frame: 5, frameTimer: 0, isHovered: false, scale: 1, targetScale: 1,
            opacity: 0.4, targetOpacity: 0.4
        };
        let scrollButton = {
            x: 0, y: canvas.height,
            targetY: 0,
            width: 120, height: 120,
            frame: 0, frameTimer: 0, isAnimating: false, animationDirection: 1, scale: 1
        };
        let shareButton = {
            x: 0, y: 0, width: 80, height: 80,
            frame: 0, frameTimer: 0, scale: 1
        };
        let socialButtons = [];


        // --- Animation Data ---
        const animationStates = {
            run: { frames: 10, columns: 4, frameDuration: 0.08 },
            jump: { frames: 23, columns: 5, frameDuration: 0.03},
            crouch: { frames: 10, columns: 4, frameDuration: 0.08 },
            fall: { frames: 26, columns: 6, frameDuration: 0.04 },
            teleport: { frames: 10, columns: 4, frameDuration: 0.035 },
            teleportGold: { frames: 20, columns: 5, frameDuration: 0.05 },
            shuriken: { frames: 6, columns: 3, frameDuration: 0.05 },
            runCloud: { frames: 24, columns: 5, frameDuration: 0.08},
            menuIntro: { frames: 28, columns: 4, frameDuration: 0.04, spriteWidth: 500, spriteHeight: 250 },
            menuLoop: { frames: 28, columns: 4, frameDuration: 0.1, spriteWidth: 500, spriteHeight: 250 },
            menuOutro: { frames: 28, columns: 4, frameDuration: 0.04, spriteWidth: 500, spriteHeight: 250 },
            button: { frames: 10, columns: 4, frameDuration: 0.05, spriteWidth: 80, spriteHeight: 80 },
            rotate: { frames: 28, columns: 7, frameDuration: 0.05, spriteWidth: 250, spriteHeight: 500 },
            tap: { frames: 28, columns: 4, frameDuration: 0.08, spriteWidth: 500, spriteHeight: 250 },
            space: { frames: 28, columns: 4, frameDuration: 0.08, spriteWidth: 500, spriteHeight: 250 },
            scroll: { frames: 14, columns: 4, frameDuration: 0.05, spriteWidth: 120, spriteHeight: 120 },
            volume: { frames: 6, columns: 3, frameDuration: 0.05, spriteWidth: 100, spriteHeight: 100 },
            share: { frames: 9, columns: 3, frameDuration: 0.08, spriteWidth: 100, spriteHeight: 100 },
            shareIcon: { frames: 9, columns: 3, frameDuration: 0.08, spriteWidth: 100, spriteHeight: 100 }
        };

        // --- Asset Loading ---
        const GITHUB_REPO_URL = 'https://maxedoutpotato.github.io/NinjaRunnerGame/';
        const images = {};
        const sounds = {};
        const imageSources = {
            menuIntro: `Assets/Menu/${isMobile ? 'Intro.mobile.png' : 'Intro.png'}`,
            menuLoop: `Assets/Menu/${isMobile ? 'Loop.mobile.png' : 'Loop.png'}`,
            menuOutro: `Assets/Menu/${isMobile ? 'Outro.mobile.png' : 'Outro.png'}`,
            button: 'Assets/Menu/Button.png',
            rotate: 'Assets/Menu/Rotate.png',
            tap: 'Assets/Menu/Tap.png',
            space: 'Assets/Menu/Space.png',
            ground: 'Assets/Background/Ground.png',
            background1: 'Assets/Background/Background.1.png',
            background2: 'Assets/Background/Background.2.png',
            mountain: 'Assets/Background/background.mountain.png',
            grass: 'Assets/Background/Grass.png',
            run: 'Assets/Ninja.Main/Run.png',
            jump: 'Assets/Ninja.Main/Jump.png',
            crouch: 'Assets/Ninja.Main/Run.Crouch.png',
            fall: 'Assets/Ninja.Main/Fall.png',
            runCloud: 'Assets/Ninja.Main/Run.Cloud.png',
            teleport: 'Assets/Ninja.Main/Teleport.png',
            teleportLogo: 'Assets/Ninja.Main/Teleport.Logo.png',
            teleportGold: 'Assets/Ninja.Main/Teleport.Gold.png',
            shuriken: 'Assets/Obstacles/Shuriken.png',
            lantern: 'Assets/Obstacles/Lantern.png',
            rock: 'Assets/Obstacles/Rock.png',
            apple: 'Assets/Obstacles/Apple.png',
            carrot: 'Assets/Obstacles/Carrot.png',
            scroll: 'Assets/Menu/Scroll.png',
            volume: 'Assets/Menu/Volume.png',
            share: 'Assets/Menu/Share.png',
            shareTwitter: 'Assets/Menu/X.png',
            shareWhatsApp: 'Assets/Menu/WhatsApp.png',
            shareFacebook: 'Assets/Menu/Facebook.png',
            shareReddit: 'Assets/Menu/Reddit.png',
            shareTelegram: 'Assets/Menu/Telegram.png'
        };
        const soundSources = {
            intro: 'Audio/Intro.mp3',
            gateClose: 'Audio/Gate.Close.mp3',
            gecko: 'Audio/Gecko.mp3',
            start: 'Audio/Gong.Start.mp3', end: 'Audio/Gong.End.mp3', jump: 'Audio/Jump.mp3',
            roll: 'Audio/Roll.mp3', woosh: 'Audio/Woosh.mp3', kabuki: 'Audio/Kabuki.mp3',
            track: 'Audio/Track.mp3', fail: 'Audio/Fail.mp3', bell: 'Audio/Bell.mp3',
            teleport: 'Audio/Teleport.mp3', crouch: 'Audio/Crouch.mp3', eat: 'Audio/Eat.mp3', secret: 'Audio/Secret.mp3',
            bounce: 'Audio/Bounce.mp3',
            paper: 'Audio/Paper.mp3'
        };
        let assetsLoaded = 0;
        const totalAssets = Object.keys(imageSources).length + Object.keys(soundSources).length;

        function assetLoadCallback(type, src) {
            if (type === 'error') {
                console.warn(`Failed to load asset, but continuing: ${src}`);
            }
            assetsLoaded++;
        }

        function preloadAssets() {
            for (const key in imageSources) {
                images[key] = new Image();
                const src = GITHUB_REPO_URL + imageSources[key];
                images[key].src = src;
                images[key].onload = () => assetLoadCallback('success', src);
                images[key].onerror = () => assetLoadCallback('error', src);
            }
            for (const key in soundSources) {
                sounds[key] = new Audio();
                const src = GITHUB_REPO_URL + soundSources[key];
                sounds[key].src = src;
                if (key === 'track' || key === 'intro' || key === 'gecko') sounds[key].loop = true;
                sounds[key].addEventListener('canplaythrough', () => assetLoadCallback('success', src), { once: true });
                sounds[key].onerror = () => assetLoadCallback('error', src);
            }
        }
        
        // --- Social Sharing ---
        function shareOnTwitter(score) {
            const text = `I just scored ${score} in Ninja Runner! Can you beat my high score?`;
            const url = 'https://maxedoutpotato.github.io/NinjaRunnerGame/';
            const hashtags = 'NinjaRunnerGame,IndieGame,WebGame,JavaScript,GameDev';
            const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}&hashtags=${hashtags}`;
            window.open(twitterUrl, '_blank');
        }

        function shareOnFacebook(score) {
            const url = 'https://maxedoutpotato.github.io/NinjaRunnerGame/';
            const facebookUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}`;
            window.open(facebookUrl, '_blank');
        }

        function shareOnReddit(score) {
            const text = `I just scored ${score} in Ninja Runner! Can you beat my high score?`;
            const url = 'https://maxedoutpotato.github.io/NinjaRunnerGame/';
            const redditUrl = `https://www.reddit.com/submit?url=${encodeURIComponent(url)}&title=${encodeURIComponent(text)}`;
            window.open(redditUrl, '_blank');
        }

        function shareOnWhatsApp(score) {
            const text = `I just scored ${score} in Ninja Runner! Can you beat my high score?`;
            const url = 'https://maxedoutpotato.github.io/NinjaRunnerGame/';
            const whatsappUrl = `whatsapp://send?text=${encodeURIComponent(text + ' ' + url)}`;
            window.open(whatsappUrl, '_blank');
        }

        function shareOnTelegram(score) {
            const text = `I just scored ${score} in Ninja Runner! Can you beat my high score?`;
            const url = 'https://maxedoutpotato.github.io/NinjaRunnerGame/';
            const telegramUrl = `https://t.me/share/url?url=${encodeURIComponent(url)}&text=${encodeURIComponent(text)}`;
            window.open(telegramUrl, '_blank');
        }


        // --- Input Handling ---
        function handleJump() {
            if (!player.isJumping && !gameOver) {
                wantsToCrouch = false;
                player.isJumping = true;
                player.velocityY = JUMP_STRENGTH;
                player.state = 'jump';
                player.frame = 0;
                sounds.jump.currentTime = 0;
                sounds.jump.play();
                effectsArray.forEach(effect => { if(effect.startFading) effect.startFading() });
            }
        }

        function handleCrouchStart() {
            if (player.isJumping) {
                wantsToCrouch = true;
                return;
            }
            if (gameStarted && !player.isJumping && !player.isCrouching) {
                player.isCrouching = true;
                player.state = 'crouch';
                sounds.crouch.currentTime = 0;
                sounds.crouch.play();
            }
        }

        function handleCrouchEnd() {
            wantsToCrouch = false;
            if (player.isCrouching) {
                player.isCrouching = false;
                player.state = 'run';
            }
        }

        document.addEventListener('keydown', function(event) {
            if (isRestarting || isResetting || isRestartButtonAnimating) return;

            if (event.code === 'Space' || event.code === 'ArrowUp') {
                 if (menuState === 'pre-menu') {
                     unlockAudio();
                     return;
                 }
                if ((gameOver || gameWon) && canRestart) {
                    isRestarting = true;
                    canRestart = false;
                    return;
                }
                if (!gameStarted) {
                    if (menuState === 'loop') {
                        menuState = 'outro';
                        menuFrame = 0;
                        menuFrameTimer = 0;
                        sounds.intro.pause();
                        sounds.intro.currentTime = 0;
                        startGame();
                    }
                } else {
                    handleJump();
                }
            }
            
            if (gameOver || !gameStarted) return;

            if ((event.code === 'KeyS' || event.code === 'ArrowDown')) {
                handleCrouchStart();
            }
        });
        document.addEventListener('keyup', function(event) {
            if (gameOver || isRestarting || !gameStarted || isResetting) return;
            if (event.code === 'KeyS' || event.code === 'ArrowDown') {
                handleCrouchEnd();
            }
        });

        // --- Mouse/Touch Controls ---
        function getScaledCoordinates(evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            let clientX = 0;
            let clientY = 0;
            
            if (evt.type.startsWith('touch')) {
                 if (evt.changedTouches && evt.changedTouches[0]) {
                    clientX = evt.changedTouches[0].clientX;
                    clientY = evt.changedTouches[0].clientY;
                }
            } else {
                clientX = evt.clientX || 0;
                clientY = evt.clientY || 0;
            }
            
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }
        
        canvas.addEventListener('mousemove', (evt) => {
            const mousePos = getScaledCoordinates(evt);
            if (!mousePos) return;

            const volBtn = volumeButton;
            const volBtnPadding = 10;
            if (mousePos.x >= volBtn.x - volBtnPadding && mousePos.x <= volBtn.x + volBtn.width + volBtnPadding &&
                mousePos.y >= volBtn.y - volBtnPadding && mousePos.y <= volBtn.y + volBtn.height + volBtnPadding) {
                if (!volBtn.isHovered) {
                    volBtn.isHovered = true;
                    volBtn.targetScale = 1.4;
                    volBtn.targetOpacity = 1.0;
                }
            } else {
                if (volBtn.isHovered) {
                    volBtn.isHovered = false;
                    volBtn.targetScale = 1.0;
                    volBtn.targetOpacity = 0.4;
                }
            }

            if (!canRestart) {
                canvas.style.cursor = 'default';
                return;
            };
            const isHoveringRestart = (mousePos.x >= restartButton.x && mousePos.x <= restartButton.x + restartButton.width &&
                mousePos.y >= restartButton.y && mousePos.y <= restartButton.y + restartButton.height);

            if (isHoveringRestart && !restartButton.isHovered) {
                restartButton.isHovered = true;
                canvas.style.cursor = 'pointer';
                if(sounds.gecko) {
                    sounds.gecko.currentTime = 0;
                    sounds.gecko.play();
                }
            } else if (!isHoveringRestart && restartButton.isHovered) {
                restartButton.isHovered = false;
                canvas.style.cursor = 'default';
                 if(sounds.gecko) {
                    sounds.gecko.pause();
                }
            }
        });

        function handleCanvasRelease(pos) {
             if (isInfoBoxVisible) {
                isInfoBoxVisible = false;
                scrollButton.isAnimating = true;
                scrollButton.animationDirection = -1;
                sounds.paper.currentTime = 0;
                sounds.paper.play();
                return true;
            }

            const volBtn = volumeButton;
            const volBtnPadding = isMobile ? 30 : 10;
            if (pos.x >= volBtn.x - volBtnPadding && pos.x <= volBtn.x + volBtn.width + volBtnPadding &&
                pos.y >= volBtn.y - volBtnPadding && pos.y <= volBtn.y + volBtn.height + volBtnPadding) {
                toggleMute();
                if (isMobile) {
                    volBtn.targetScale = 1.4;
                    volBtn.targetOpacity = 1.0;
                    setTimeout(() => {
                        if (!volBtn.isHovered) {
                            volBtn.targetScale = 1.0;
                            volBtn.targetOpacity = 0.4;
                        }
                    }, 150);
                }
                return true;
            }

            if (isShareMenuOpen) {
                for (const btn of socialButtons) {
                    const padding = isMobile ? 20 : 10;
                    if (btn.visible && pos.x >= btn.x - padding && pos.x <= btn.x + btn.width + padding &&
                        pos.y >= btn.y - padding && pos.y <= btn.y + btn.height + padding) {
                        btn.action(score);
                        return true;
                    }
                }
            }

            const shareBtn = shareButton;
            const shareBtnPadding = isMobile ? 20 : 10;
            if ((gameOver || gameWon) && canRestart && !isShareMenuOpen &&
                pos.x >= shareBtn.x - shareBtnPadding && pos.x <= shareBtn.x + shareBtn.width + shareBtnPadding &&
                pos.y >= shareBtn.y - shareBtnPadding && pos.y <= shareBtn.y + shareBtn.height + shareBtnPadding) {
                isShareMenuOpen = true;
                socialButtons.forEach((btn, index) => {
                    btn.isAnimatingIn = true;
                    btn.animationDelay = index * 0.1; 
                });
                return true; 
            }

            const restartBtnPadding = isMobile ? 30 : 0;
            if (canRestart && (gameOver || gameWon) &&
                 pos.x >= restartButton.x - restartBtnPadding && pos.x <= restartButton.x + restartButton.width + restartBtnPadding &&
                 pos.y >= restartButton.y - restartBtnPadding && pos.y <= restartButton.y + restartButton.height + restartBtnPadding) {
                
                 if (isMobile) {
                    if (!isRestartButtonAnimating) {
                        isRestartButtonAnimating = true;
                        restartButton.frame = 0; 
                        sounds.gecko.currentTime = 0;
                        sounds.gecko.play();
                        canRestart = false; 
                    }
                } else { // PC logic
                    isResetting = true;
                    menuState = 'intro';
                    menuFrame = 0;
                    menuFrameTimer = 0;
                    canRestart = false;
                    sounds.gateClose.play();
                    if(sounds.gecko) sounds.gecko.pause();
                }
                return true;
            }

            const scrollBtn = scrollButton;
            const scrollBtnPadding = isMobile ? 30 : 0;
            if (menuState === 'loop' &&
                pos.x >= scrollBtn.x - scrollBtnPadding && pos.x <= scrollBtn.x + scrollBtn.width + scrollBtnPadding &&
                pos.y >= scrollBtn.y - scrollBtnPadding && pos.y <= scrollBtn.y + scrollBtn.height + scrollBtnPadding) {
                isInfoBoxVisible = true;
                scrollButton.isAnimating = true;
                scrollButton.animationDirection = 1;
                sounds.paper.currentTime = 0;
                sounds.paper.play();
                return true;
            }

            return false;
        }

        canvas.addEventListener('mousedown', (evt) => {
            handleCanvasRelease(getScaledCoordinates(evt));
        });

        canvas.addEventListener('mouseup', (evt) => {
             // handleCanvasRelease is now in mousedown for PC, this can be empty
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (isRestarting || isResetting || isRestartButtonAnimating) return;
            touchStartTime = Date.now();
            isHoldingTouch = true;
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (isRestarting || isResetting || isRestartButtonAnimating) return;
            
            const touchPos = getScaledCoordinates(e);
            if (!touchPos) return;

            if (handleCanvasRelease(touchPos)) {
                isHoldingTouch = false;
                touchStartTime = 0;
                return;
            }
            isHoldingTouch = false;

            if (menuState === 'pre-menu') {
                unlockAudio();
                return;
            }

            if ((gameOver || gameWon) && canRestart) {
                isRestarting = true;
                canRestart = false;
                return;
            }
            
            const touchDuration = Date.now() - touchStartTime;
            if (gameStarted && touchDuration > 0) { 
                if (touchDuration < 250) handleJump();
                handleCrouchEnd();
            } else if (!gameStarted && menuState === 'loop') {
                menuState = 'outro';
                menuFrame = 0;
                menuFrameTimer = 0;
                sounds.intro.pause();
                sounds.intro.currentTime = 0;
                startGame();
            }
            touchStartTime = 0;
        }, { passive: false });

        // --- Sound Utility ---
        function unlockAudio() {
            if (audioUnlocked) return;
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            for (const key in sounds) {
                sounds[key].play().then(() => {
                    sounds[key].pause();
                    sounds[key].currentTime = 0;
                }).catch(e => {});
            }
            audioUnlocked = true;
            showPreMenuBehindIntro = true;
            
            setTimeout(() => {
                menuState = 'intro'; 
                sounds.intro.play();
                sounds.gateClose.play();
            }, 50);
        }

        function toggleMute() {
            isMuted = !isMuted;
            for (const key in sounds) {
                sounds[key].muted = isMuted;
            }
        }

        // --- All Classes (Full logic restored) ---
        class VisualEffect { constructor() { this.markedForDeletion = false; } }
        class TeleportEffect extends VisualEffect {
            constructor(x, y, followsPlayer) {
                super();
                this.image = images.teleport;
                this.spriteWidth = 100; this.spriteHeight = 100;
                this.width = 150; this.height = 150;
                this.x = x - (this.width - player.width) / 2;
                this.y = y - (this.height - player.height) / 2;
                this.frame = 0; this.frameTimer = 0;
                this.followsPlayer = followsPlayer;
            }
            update(deltaTime) {
                if (this.followsPlayer) {
                    this.x = player.x - (this.width - player.width) / 2;
                    this.y = player.y - (this.height - player.height) / 2;
                }
                this.frameTimer += deltaTime;
                const stateData = animationStates.teleport;
                if (this.frameTimer >= stateData.frameDuration) {
                    this.frame++; this.frameTimer = 0;
                }
                if (this.frame >= stateData.frames) {
                    this.markedForDeletion = true; player.isTeleporting = false;
                }
            }
            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    const stateData = animationStates.teleport;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                }
            }
        }
        class RunCloud extends VisualEffect {
             constructor() {
                super();
                this.image = images.runCloud;
                this.spriteWidth = 100; this.spriteHeight = 100;
                this.width = 100; this.height = 100;
                this.x = player.x + RUN_CLOUD_OFFSET_X;
                this.y = player.y + RUN_CLOUD_OFFSET_Y;
                this.frame = 0; this.frameTimer = 0;
                this.opacity = 0; this.isFading = false;
            }
            startFading() { this.isFading = true; }
            activate() { this.isFading = false; this.x = player.x + RUN_CLOUD_OFFSET_X; }
            update(deltaTime) {
                if (this.isFading) {
                    if (this.opacity > 0) {
                        this.opacity -= 2 * deltaTime;
                        this.x -= gameSpeed * 0.2 * deltaTime;
                    }
                } else {
                    if (this.opacity < 1) this.opacity += 2 * deltaTime;
                    this.x = player.x + RUN_CLOUD_OFFSET_X;
                    this.y = player.y + RUN_CLOUD_OFFSET_Y;
                    this.frameTimer += deltaTime;
                    const stateData = animationStates.runCloud;
                    const dynamicFrameDuration = Math.max(0.02, stateData.frameDuration - (gameSpeed / 10000));
                    if (this.frameTimer >= dynamicFrameDuration) {
                        this.frame = (this.frame + 1) % stateData.frames;
                        this.frameTimer = 0;
                    }
                }
            }
            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0 && this.opacity > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    const stateData = animationStates.runCloud;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                    ctx.restore();
                }
            }
        }
        class FloatingScore {
            constructor(value, x, y, color = {r:0, g:100, b:0}) {
                this.value = value; this.x = x; this.y = y; this.color = color;
                this.opacity = 1; this.timer = 0;
            }
            update(deltaTime) {
                this.y -= 30 * deltaTime; this.timer += deltaTime;
                if (this.timer > 1.3) this.opacity -= 1.2 * deltaTime;
            }
            draw() {
                ctx.save();
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`;
                ctx.textAlign = 'center';
                
                const plusSign = '+';
                const valueText = this.value.toString();

                ctx.font = 'bold 24px "Segoe UI"';
                const plusWidth = ctx.measureText(plusSign).width;
                ctx.font = '24px Amanojaku, "Segoe UI"';
                const valueWidth = ctx.measureText(valueText).width;
                const totalWidth = plusWidth + valueWidth;
                const startX = (this.x - totalWidth / 2) + 15; // Shifted right

                ctx.font = 'bold 24px "Segoe UI"';
                ctx.fillText(plusSign, startX + plusWidth / 2, this.y);
                
                ctx.font = '24px Amanojaku, "Segoe UI"';
                ctx.fillText(valueText, startX + plusWidth + valueWidth / 2, this.y);
                ctx.restore();
            }
        }
        class SceneryObject {
            constructor() { this.x = canvas.width + Math.random() * 50; }
            update(deltaTime) { this.x -= gameSpeed * this.speedModifier * deltaTime; }
        }
        class Mountain extends SceneryObject {
            constructor() {
                super();
                this.image = images.mountain;
                this.scale = (Math.random() * MOUNTAIN_SCALE_VARIANCE * 1.3) + (MOUNTAIN_AVG_SCALE - MOUNTAIN_SCALE_VARIANCE);
                this.width = this.image.width * this.scale;
                this.height = this.image.height * this.scale;
                this.y = MOUNTAIN_Y_POS; this.speedModifier = 0.06;
            }
            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                }
            }
        }
        class Obstacle {
             constructor() { this.x = canvas.width; this.frame = 0; this.frameTimer = 0; this.passed = false; }
             update(deltaTime) { this.x -= gameSpeed * this.speedModifier * deltaTime; }
        }
        class Shuriken extends Obstacle {
            constructor() {
                super();
                this.image = images.shuriken;
                this.spriteWidth = 50; this.spriteHeight = 50;
                this.width = 70; this.height = 70;
                this.y = SHURIKEN_FLYING_HEIGHTS[Math.floor(Math.random() * SHURIKEN_FLYING_HEIGHTS.length)];
                this.speedModifier = 1.1; this.hitbox = { offsetX: 15, offsetY: 15, width: 45, height: 40 };
            }
            update(deltaTime) {
                super.update(deltaTime);
                this.frameTimer += deltaTime;
                const stateData = animationStates.shuriken;
                if (this.frameTimer >= stateData.frameDuration) {
                    this.frame = (this.frame + 1) % stateData.frames;
                    this.frameTimer = 0;
                }
            }
            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    const stateData = animationStates.shuriken;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                    if (DEBUG_MODE) {
                        ctx.save();
                        ctx.strokeStyle = 'red';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(this.x + this.hitbox.offsetX, this.y + this.hitbox.offsetY, this.hitbox.width, this.hitbox.height);
                        ctx.restore();
                    }
                }
            }
        }
        class Lantern extends Obstacle {
            constructor() {
                super();
                this.image = images.lantern;
                this.width = 90; this.height = 90;
                this.y = PLAYER_GROUND_LEVEL + PLAYER_DRAW_HEIGHT - this.height - 1;
                this.speedModifier = 1.0;
                this.hitbox = { offsetX: 18, offsetY: 10, width: 55, height: 65 };
            }
             draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                    if (DEBUG_MODE) {
                        ctx.save();
                        ctx.strokeStyle = 'red';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(this.x + this.hitbox.offsetX, this.y + this.hitbox.offsetY, this.hitbox.width, this.hitbox.height);
                        ctx.restore();
                    }
                }
             }
        }
        class Rock extends Obstacle {
            constructor() {
                super();
                this.image = images.rock;
                this.width = 140; this.height = 130;
                this.y = PLAYER_GROUND_LEVEL + PLAYER_DRAW_HEIGHT - this.height + 20;
                this.speedModifier = 1.0;
                this.hitbox = { offsetX: 40, offsetY: 60 , width: 60, height: 45 };
            }
            draw() {
                 if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                    if (DEBUG_MODE) {
                        ctx.save();
                        ctx.strokeStyle = 'red';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(this.x + this.hitbox.offsetX, this.y + this.hitbox.offsetY, this.hitbox.width, this.hitbox.height);
                        ctx.restore();
                    }
                }
            }
        }
        class TeleportGold extends Obstacle {
            constructor() {
                super();
                this.image = images.teleportGold;
                this.spriteWidth = 80; this.spriteHeight = 80;
                this.width = 60; this.height = 60;
                this.y = SHURIKEN_FLYING_HEIGHTS[Math.floor(Math.random() * SHURIKEN_FLYING_HEIGHTS.length)];
                this.speedModifier = 1; this.hitbox = { offsetX: 0, offsetY: 0, width: 60, height: 60 };
            }
            update(deltaTime) {
                super.update(deltaTime);
                this.frameTimer += deltaTime;
                const stateData = animationStates.teleportGold;
                if (this.frameTimer >= stateData.frameDuration) {
                    this.frame = (this.frame + 1) % stateData.frames;
                    this.frameTimer = 0;
                }
            }
            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    const stateData = animationStates.teleportGold;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                }
            }
        }
        class BonusPoints extends Obstacle {
            constructor() {
                super();
                this.image = Math.random() < 0.5 ? images.apple : images.carrot;
                this.width = 80; this.height = 80;
                this.y = SHURIKEN_FLYING_HEIGHTS[Math.floor(Math.random() * SHURIKEN_FLYING_HEIGHTS.length)];
                this.speedModifier = 1;
                this.hitbox = { offsetX: 0, offsetY: 0, width: 80, height: 80 };
            }
            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                }
            }
        }

        // --- Game Logic Handlers ---
        function handleScenery(deltaTime) {
            sceneryArray.forEach(item => item.update(deltaTime));
            sceneryArray = sceneryArray.filter(item => item.x > -item.width);
            if (gameOver || isRestarting || isResetting) return;
            const minMountainSpawnDistance = canvas.width;
            const mountainSpawnChance = 0.005;
            let canSpawnMountain = sceneryArray.length === 0 || sceneryArray[sceneryArray.length - 1].x < canvas.width - minMountainSpawnDistance;
            if (canSpawnMountain && Math.random() < mountainSpawnChance) {
                sceneryArray.push(new Mountain());
            }
        }
        function handleObstacles(deltaTime) {
            obstaclesArray.forEach(obstacle => obstacle.update(deltaTime));
            if (gameOver || isRestarting || isResetting) return;
            const minSpawnDistance = canvas.width / 1.1;
            const spawnChance = 0.015;
            let canSpawn = (obstaclesArray.length === 0 && !isRestarting) || (obstaclesArray.length > 0 && obstaclesArray[obstaclesArray.length - 1].x < canvas.width - minSpawnDistance);
            if (canSpawn && Math.random() < spawnChance) {
                let currentMilestoneKey = '0';
                if (score < 3000) currentMilestoneKey = '3000';
                else if (score < 6000) currentMilestoneKey = '6000';
                else if (score < 9000) currentMilestoneKey = '9000';
                else if (score < 12000) currentMilestoneKey = '12000';
                else if (score < 15000) currentMilestoneKey = '15000';
                else if (score < 18000) currentMilestoneKey = '18000';
                else if (score < 21000) currentMilestoneKey = '21000';
                let bonusSpawned = false;
                if (bonusLimits.teleportGold[currentMilestoneKey] && bonusSpawns.teleportGold[currentMilestoneKey] < bonusLimits.teleportGold[currentMilestoneKey] && Math.random() < 0.15) {
                    obstaclesArray.push(new TeleportGold());
                    bonusSpawns.teleportGold[currentMilestoneKey]++;
                    bonusSpawned = true;
                } 
                else if (bonusLimits.bonusPoints[currentMilestoneKey] && bonusSpawns.bonusPoints[currentMilestoneKey] < bonusLimits.bonusPoints[currentMilestoneKey] && Math.random() < 0.25) {
                    obstaclesArray.push(new BonusPoints());
                    bonusSpawns.bonusPoints[currentMilestoneKey]++;
                    bonusSpawned = true;
                }
                if (!bonusSpawned) {
                    const obstacleType = Math.random();
                    if (obstacleType < 0.4) obstaclesArray.push(new Shuriken());
                    else if (Math.random() < 0.5) obstaclesArray.push(new Lantern());
                    else obstaclesArray.push(new Rock());
                }
            }
        }
        function addScore(points, color = {r:0, g:100, b:0}) {
            const oldScore = score;
            score += points;

            if (Math.floor(score / 1000) > Math.floor(oldScore / 1000)) {
                sounds.kabuki.play();
                scoreBounceTimer = 0.5;
            }
            if (score >= scoreMilestone * 3000) {
                resetGameForNextLevel();
                return true;
            }
            floatingScores.push(new FloatingScore(points, player.x + player.width / 2 + 30, player.y, color));
            return false;
        }
        function checkCollisionsAndScore() {
            if (gameOver) return;
            const playerHitbox = player.isCrouching ? player.crouchHitbox : player.hitbox;
            const px = player.x + playerHitbox.offsetX;
            const py = player.y + playerHitbox.offsetY;
            const pw = playerHitbox.width;
            const ph = playerHitbox.height;
            for (let i = obstaclesArray.length - 1; i >= 0; i--) {
                const obstacle = obstaclesArray[i];
                const ox = obstacle.x + obstacle.hitbox.offsetX;
                const oy = obstacle.y + obstacle.hitbox.offsetY;
                const ow = obstacle.hitbox.width;
                const oh = obstacle.hitbox.height;
                if (px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy) {
                    if (obstacle instanceof TeleportGold) {
                        teleportCharges++;
                        teleportBounceTimer = 1;
                        sounds.secret.currentTime = 0;
                        sounds.secret.play();
                        obstaclesArray.splice(i, 1);
                    } else if (obstacle instanceof BonusPoints) {
                        const points = Math.floor(Math.random() * 151) + 150;
                        const didReset = addScore(points, {r: 0, g: 100, b: 255});
                        sounds.eat.currentTime = 0;
                        sounds.eat.play();
                        obstaclesArray.splice(i, 1);
                        if (didReset) return;
                    } else if (teleportCharges > 0) {
                        teleportCharges--;
                        player.isTeleporting = true;
                        sounds.teleport.currentTime = 0;
                        sounds.teleport.play();
                        effectsArray.push(new TeleportEffect(player.x, player.y, player.isJumping));
                        obstaclesArray.splice(i, 1);
                    } else {
                        gameOver = true;
                        player.state = 'fall';
                        player.frame = 0;
                        sounds.end.play();
                        sounds.fail.play();
                        sounds.track.pause();
                        sounds.track.currentTime = 0;
                        setTimeout(() => { canRestart = true; }, 2000);
                    }
                }
                if (!obstacle.passed && obstacle.x + obstacle.width < player.x) {
                    obstacle.passed = true;
                    if (!(obstacle instanceof TeleportGold) && !(obstacle instanceof BonusPoints)) {
                        sounds.woosh.currentTime = 0;
                        sounds.woosh.play();
                        const points = 100;
                        const didReset = addScore(points);
                        if (didReset) return;
                    }
                }
            }
        }
        function resetGameForNextLevel() {
            gameSpeed = 300;
            obstaclesArray = [];
            floatingScores = [];
            sounds.bell.play();
            scoreMilestone++;
            if (score >= 21000) {
                gameWon = true;
                inversionTarget = 1;
                sounds.track.pause();
                setTimeout(() => { canRestart = true; }, 2000);
            } else if (score >= 15000 && score < 18000) {
                 inversionTarget = 1;
            } else if (score >= 9000 && score < 12000) {
                 inversionTarget = 1;
            } else if (score >= 3000 && score < 6000) {
                 inversionTarget = 1;
            } else {
                 inversionTarget = 0;
            }
            if (!player.isJumping) {
                player.state = 'run';
                player.frame = 0;
            }
        }

        function fullGameReset() {
            isResetting = false;
            gameOver = false; gameWon = false; gameSpeed = 300; score = 0;
            gameOverFade = 0; uiFadeInTimer = 0;
            obstaclesArray = []; sceneryArray = []; effectsArray = []; floatingScores = [];
            scoreMilestone = 1; teleportCharges = 0; inversionAmount = 0; inversionTarget = 0;
            scoreBounceTimer = 0; teleportBounceTimer = 0;
            wantsToCrouch = false;
            isShareMenuOpen = false;
            gameOverTextFade = 1;
            socialButtons.forEach(btn => {
                btn.visible = false;
                btn.scale = 0;
                btn.isAnimatingIn = false;
            });
            bonusSpawns = {
                teleportGold: { '3000': 0, '9000': 0, '15000': 0 },
                bonusPoints: { '3000': 0, '6000': 0, '9000': 0, '12000': 0, '15000': 0, '18000': 0, '21000': 0 }
            };
            player.y = PLAYER_GROUND_LEVEL; player.state = 'run'; player.frame = 0; player.frameTimer = 0;
            player.isJumping = false; player.isCrouching = false; player.isTeleporting = false; player.velocityY = 0;
        }

        // --- Game/Menu Loops ---
        function updateMenu(deltaTime) {
            menuFrameTimer += deltaTime;
            let stateData;
            if (menuState === 'intro') stateData = animationStates.menuIntro;
            else if (menuState === 'loop') stateData = animationStates.menuLoop;
            else if (menuState === 'outro') stateData = animationStates.menuOutro;

            if (stateData && menuFrameTimer >= stateData.frameDuration) {
                menuFrame++;
                menuFrameTimer = 0;
                
                if (menuState === 'intro' && menuFrame >= stateData.frames) {
                    showPreMenuBehindIntro = false;
                    if (isResetting) {
                        fullGameReset();
                        gameStarted = false;
                        menuState = 'loop';
                        menuFrame = 0;
                        sounds.intro.currentTime = 0;
                        sounds.intro.play();
                    } else {
                        menuState = 'loop';
                        menuFrame = 0;
                    }
                } else if (menuState === 'loop' && menuFrame >= stateData.frames) {
                    menuFrame = 0;
                } else if (menuState === 'outro' && menuFrame >= stateData.frames) {
                    menuState = 'inactive';
                }
            }
        }

        function startGame() {
            gameStarted = true;
            sounds.start.play();
            sounds.roll.play();
            sounds.track.currentTime = 0;
            sounds.track.play();
            effectsArray.push(new RunCloud());
        }
        
        // --- Main Update and Draw Functions ---
        function update(deltaTime) {
            // This needs to update every frame for the portrait mode message
            rotateFrameTimer += deltaTime;
            const rotateData = animationStates.rotate;
            if (rotateData && rotateFrameTimer >= rotateData.frameDuration) {
                rotateFrame = (rotateFrame + 1) % rotateData.frames;
                rotateFrameTimer = 0;
            }

            // UI Button animations should always update
            const volBtn = volumeButton;
            volBtn.scale += (volBtn.targetScale - volBtn.scale) * 0.2;
            volBtn.opacity += (volBtn.targetOpacity - volBtn.opacity) * 0.2;
            volBtn.frameTimer += deltaTime;
            const volAnimData = animationStates.volume;
            if (volAnimData && volBtn.frameTimer >= volAnimData.frameDuration) {
                if (isMuted && volBtn.frame > 0) {
                    volBtn.frame--;
                    volBtn.frameTimer = 0;
                } else if (!isMuted && volBtn.frame < volAnimData.frames - 1) {
                    volBtn.frame++;
                    volBtn.frameTimer = 0;
                }
            }

            // Scroll button slide animation
            if (menuState === 'intro' || menuState === 'loop') {
                scrollButton.y += (scrollButton.targetY - scrollButton.y) * 0.05;
            } else {
                scrollButton.y += (canvas.height + 50 - scrollButton.y) * 0.05;
            }

            if (menuState === 'loop' && !scrollButton.isAnimating && !isInfoBoxVisible) {
                const pulse = 1 + Math.sin(lastTime / 500) * 0.05;
                scrollButton.scale = pulse;
            } else {
                scrollButton.scale = 1;
            }

            // Scroll button frame animation
            if (scrollButton.isAnimating) {
                scrollButton.frameTimer += deltaTime;
                const scrollAnimData = animationStates.scroll;
                if (scrollAnimData && scrollButton.frameTimer >= scrollAnimData.frameDuration) {
                    scrollButton.frame += scrollButton.animationDirection;
                    scrollButton.frameTimer = 0;
                    if (scrollButton.frame >= scrollAnimData.frames - 1 || scrollButton.frame <= 0) {
                        scrollButton.frame = Math.max(0, Math.min(scrollAnimData.frames - 1, scrollButton.frame));
                        scrollButton.isAnimating = false;
                    }
                }
            }

            if (menuState === 'pre-menu' || showPreMenuBehindIntro) {
                preMenuFrameTimer += deltaTime;
                const preMenuAnimation = isMobile ? animationStates.tap : animationStates.space;
                if (preMenuAnimation && preMenuFrameTimer >= preMenuAnimation.frameDuration) {
                    preMenuFrame = (preMenuFrame + 1) % preMenuAnimation.frames;
                    preMenuFrameTimer = 0;
                }
                if (!showPreMenuBehindIntro) return;
            }

            if (isRestarting) {
                restartFadeAmount += 2 * fadeDirection * deltaTime;
                if (restartFadeAmount >= 1 && fadeDirection === 1) {
                    fadeDirection = -1;
                    fullGameReset();
                    startGame();
                }
                if (restartFadeAmount <= 0 && fadeDirection === -1) {
                    isRestarting = false;
                    fadeDirection = 1;
                }
            }
            
            if (isResetting || isRestartButtonAnimating) {
                 updateMenu(deltaTime);
            }

            if ((menuState === 'intro' || menuState === 'loop' || menuState === 'outro') && !isResetting && !isRestartButtonAnimating) {
                updateMenu(deltaTime);
            }

            if (isShareMenuOpen) {
                if (gameOverTextFade > 0) {
                    gameOverTextFade -= 2 * deltaTime;
                }
                shareButton.scale = 1.5; // Minimum scale

                socialButtons.forEach(btn => {
                    if (btn.isAnimatingIn) {
                        if (btn.animationDelay > 0) {
                            btn.animationDelay -= deltaTime;
                        } else {
                            btn.visible = true;
                            // Bounce effect
                            if (btn.scale < 1) {
                                btn.scale += (1.2 - btn.scale) * 0.2; // Overshoot
                            } else {
                                btn.scale += (1 - btn.scale) * 0.1; // Settle
                            }
                            if (Math.abs(1 - btn.scale) < 0.01) {
                                btn.scale = 1;
                                btn.isAnimatingIn = false;
                            }
                        }
                    }
                    if(btn.visible){
                        btn.frameTimer += deltaTime;
                        const iconAnimData = animationStates.shareIcon;
                        if (iconAnimData && btn.frameTimer >= iconAnimData.frameDuration) {
                            btn.frame = (btn.frame + 1) % iconAnimData.frames;
                            btn.frameTimer = 0;
                        }
                    }
                });

            } else if ((gameOver || gameWon) && canRestart) {
                const pulse = 1.7 + Math.sin(lastTime / 300) * 0.2;
                shareButton.scale = pulse;

                shareButton.frameTimer += deltaTime;
                const shareAnimData = animationStates.share;
                if (shareAnimData && shareButton.frameTimer >= shareAnimData.frameDuration) {
                    shareButton.frame = (shareButton.frame + 1) % shareAnimData.frames;
                    shareButton.frameTimer = 0;
                }
            } else {
                shareButton.scale = 1;
            }

            if (!gameStarted) {
                if (isRestartButtonAnimating) {
                    //fallthrough to button animation logic
                } else {
                    return;
                }
            }
            
            if (gameStarted) {
                handleScenery(deltaTime);
                handleObstacles(deltaTime);
                checkCollisionsAndScore();
                
                for (let i = floatingScores.length - 1; i >= 0; i--) {
                    floatingScores[i].update(deltaTime);
                    if (floatingScores[i].opacity <= 0) {
                        floatingScores.splice(i, 1);
                    }
                }

                if (gameOver || gameWon) {
                    if (gameSpeed > 0) gameSpeed -= 800 * deltaTime;
                    else gameSpeed = 0;
                    effectsArray.forEach(effect => { if(effect instanceof RunCloud) effect.startFading() });
                    if (gameOver && gameOverFade < 1) gameOverFade += 2 * deltaTime;
                } else {
                    if(!isRestarting) gameSpeed += speedIncreaseRate * 60 * deltaTime;
                }
                
                if (isHoldingTouch && gameStarted && !player.isJumping) {
                    const holdDuration = Date.now() - touchStartTime;
                    if (holdDuration > 200) {
                        handleCrouchStart();
                    }
                }

                if (scoreBounceTimer > 0) scoreBounceTimer -= deltaTime;
                if (teleportBounceTimer > 0) teleportBounceTimer -= deltaTime;
                
                const transitionSpeed = 1 / 4;
                if (inversionAmount < inversionTarget) {
                    inversionAmount = Math.min(inversionTarget, inversionAmount + transitionSpeed * deltaTime);
                } else if (inversionAmount > inversionTarget) {
                    inversionAmount = Math.max(inversionTarget, inversionAmount - transitionSpeed * deltaTime);
                }
                groundX -= gameSpeed * deltaTime;
                bg1X -= gameSpeed * 0.1 * deltaTime;
                bg2X -= gameSpeed * 0.03 * deltaTime;
                grassX -= gameSpeed * GRASS_SPEED_MODIFIER * deltaTime;
                
                const bg1_scaledWidth = images.background1 ? images.background1.width * BG1_SCALE : 0;
                const bg2_scaledWidth = images.background2 ? images.background2.width * BG2_SCALE : 0;
                const grass_scaledWidth = images.grass ? images.grass.width * GRASS_SCALE : 0;

                if (images.ground && groundX <= -images.ground.width) groundX += images.ground.width;
                if (bg1_scaledWidth > 0 && bg1X <= -bg1_scaledWidth) bg1X += bg1_scaledWidth;
                if (bg2_scaledWidth > 0 && bg2X <= -bg2_scaledWidth) bg2X += bg2_scaledWidth;
                if (grass_scaledWidth > 0 && grassX <= -grass_scaledWidth) grassX += grass_scaledWidth;
                
                if (player.isJumping) {
                    player.velocityY += GRAVITY * deltaTime;
                    player.y += player.velocityY * deltaTime;
                }
                if (player.y > PLAYER_GROUND_LEVEL) {
                    player.y = PLAYER_GROUND_LEVEL;
                    if(player.isJumping) {
                        effectsArray.forEach(effect => { if(effect instanceof RunCloud) effect.activate() });
                    }
                    player.isJumping = false;
                    player.velocityY = 0;
                    if (wantsToCrouch) {
                        handleCrouchStart();
                    } else if (!player.isCrouching && !gameOver) { 
                        player.state = 'run'; 
                    }
                }
                player.frameTimer += deltaTime;
                const stateData = animationStates[player.state];
                if (stateData) {
                    let dynamicFrameDuration = stateData.frameDuration;
                    if (player.state === 'run' || player.state === 'crouch') {
                        dynamicFrameDuration = Math.max(0.02, stateData.frameDuration - (gameSpeed / 10000));
                    }
                    if (player.frameTimer >= dynamicFrameDuration) {
                        if (player.state === 'fall') {
                            if (player.frame < stateData.frames - 1) player.frame++;
                        } else {
                            player.frame = (player.frame + 1) % stateData.frames;
                        }
                        player.frameTimer = 0;
                    }
                }
                effectsArray.forEach(effect => effect.update(deltaTime));
                effectsArray = effectsArray.filter(effect => !effect.markedForDeletion);
            }

            if (canRestart || isRestartButtonAnimating) {
                restartButton.frameTimer += deltaTime;
                if ((restartButton.isHovered && !isMobile) || isRestartButtonAnimating) {
                    const stateData = animationStates.button;
                    if (stateData && restartButton.frameTimer >= stateData.frameDuration) {
                        restartButton.frameTimer = 0;
                        if (isRestartButtonAnimating) {
                            restartButton.frame++;
                            if (restartButton.frame >= stateData.frames) {
                                isRestartButtonAnimating = false;
                                restartButton.frame = 0;
                                isResetting = true;
                                menuState = 'intro';
                                menuFrame = 0;
                                menuFrameTimer = 0;
                                sounds.gateClose.play();
                                if(sounds.gecko) sounds.gecko.pause();
                            }
                        } else { 
                            restartButton.frame = (restartButton.frame + 1) % stateData.frames;
                        }
                    }
                } else {
                    restartButton.frame = 0;
                }
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (menuState === 'pre-menu') {
                drawPreMenu();
            } else if (isResetting || isRestartButtonAnimating) {
                drawGameWorld(); 
                if (!isRestartButtonAnimating) {
                    drawMenu(); 
                }
            } else if (menuState === 'intro' || menuState === 'loop') {
                if (showPreMenuBehindIntro) {
                    drawPreMenu();
                }
                drawMenu();
            } else { 
                drawGameWorld();
                if (menuState === 'outro') {
                    drawMenu(); 
                }
            }

            if (menuState === 'intro' || menuState === 'loop' || menuState === 'outro') {
                drawScrollButton();
            }

            if (menuState === 'loop') {
                 drawInfoBox();
            }


            if ((canRestart && (gameOver || gameWon)) || isRestartButtonAnimating) {
                drawRestartButton();
            }
            drawVolumeButton();

            if (isRestarting) {
                ctx.fillStyle = `rgba(255, 255, 255, ${restartFadeAmount})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // --- Drawing Sub-functions ---
        function drawGameWorld() {
             ctx.save();
             ctx.filter = `invert(${inversionAmount * 100}%)`;
             ctx.fillStyle = '#f0f0f0';
             ctx.fillRect(0, 0, canvas.width, canvas.height);
             if (images.background2 && images.background2.complete && images.background2.naturalWidth > 0) {
                 const scaledWidth = images.background2.width * BG2_SCALE;
                 const scaledHeight = (images.background2.naturalHeight / images.background2.naturalWidth) * scaledWidth;
                 ctx.drawImage(images.background2, Math.floor(bg2X), BG2_Y_POS, scaledWidth, scaledHeight);
                 ctx.drawImage(images.background2, Math.floor(bg2X + scaledWidth) - 1, BG2_Y_POS, scaledWidth, scaledHeight);
                 ctx.drawImage(images.background2, Math.floor(bg2X + scaledWidth * 2) - 2, BG2_Y_POS, scaledWidth, scaledHeight);
             }
             sceneryArray.forEach(item => item.draw());
             if (images.background1 && images.background1.complete && images.background1.naturalWidth > 0) {
                 const scaledWidth = images.background1.width * BG1_SCALE;
                 const scaledHeight = (images.background1.naturalHeight / images.background1.naturalWidth) * scaledWidth;
                 ctx.drawImage(images.background1, Math.floor(bg1X), BG1_Y_POS, scaledWidth, scaledHeight);
                 ctx.drawImage(images.background1, Math.floor(bg1X + scaledWidth) - 1, BG1_Y_POS, scaledWidth, scaledHeight);
                 ctx.drawImage(images.background1, Math.floor(bg1X + scaledWidth * 2) - 2, BG1_Y_POS, scaledWidth, scaledHeight);
             }
             if (images.ground && images.ground.complete && images.ground.naturalWidth > 0) {
                 const groundY = canvas.height - GROUND_HEIGHT_PHYSICS + VISUAL_GROUND_Y_OFFSET;
                 ctx.drawImage(images.ground, Math.floor(groundX), groundY, images.ground.width, VISUAL_GROUND_HEIGHT);
                 ctx.drawImage(images.ground, Math.floor(groundX + images.ground.width) -1, groundY, images.ground.width, VISUAL_GROUND_HEIGHT);
                 ctx.drawImage(images.ground, Math.floor(groundX + images.ground.width * 2) -2, groundY, images.ground.width, VISUAL_GROUND_HEIGHT);
             }
             obstaclesArray.forEach(obstacle => obstacle.draw());
             effectsArray.forEach(effect => effect.draw());
             if (!player.isTeleporting) {
                 const playerStateData = animationStates[player.state];
                 if (images[player.state] && images[player.state].complete && images[player.state].naturalWidth > 0) {
                     const columns = playerStateData.columns;
                     const frameX = player.frame % columns;
                     const frameY = Math.floor(player.frame / columns);
                     const sourceX = frameX * PLAYER_SPRITE_WIDTH;
                     const sourceY = frameY * PLAYER_SPRITE_HEIGHT;
                     ctx.drawImage(images[player.state], sourceX, sourceY, PLAYER_SPRITE_WIDTH, PLAYER_SPRITE_HEIGHT, player.x, player.y, player.width, player.height);
                     if (DEBUG_MODE) {
                         ctx.save();
                         ctx.strokeStyle = 'blue';
                         ctx.lineWidth = 1;
                         let currentHitbox = player.isCrouching ? player.crouchHitbox : player.hitbox;
                         ctx.strokeRect(player.x + currentHitbox.offsetX, player.y + currentHitbox.offsetY, currentHitbox.width, currentHitbox.height);
                         ctx.restore();
                     }
                 }
             }
             if (images.grass && images.grass.complete && images.grass.naturalWidth > 0) {
                 const scaledWidth = images.grass.width * GRASS_SCALE;
                 const scaledHeight = images.grass.height * GRASS_SCALE;
                 ctx.drawImage(images.grass, Math.floor(grassX), GRASS_Y_POS, scaledWidth, scaledHeight);
                 ctx.drawImage(images.grass, Math.floor(grassX + scaledWidth) - 1, GRASS_Y_POS, scaledWidth, scaledHeight);
                 ctx.drawImage(images.grass, Math.floor(grassX + scaledWidth * 2) - 2, GRASS_Y_POS, scaledWidth, scaledHeight);
             }
             
             floatingScores.forEach(fs => fs.draw());
             
            if (gameStarted) {
                drawUI();
                drawEndScreens();
            }

             ctx.restore();
        }

        function drawUI() {
            ctx.save();
            if (gameStarted) uiFadeInTimer = Math.min(1, uiFadeInTimer + (1/60));
            ctx.globalAlpha = uiFadeInTimer;
            ctx.textAlign = 'right';
            const scoreNumberText = score.toString();
            
            let scoreFontSize = 30;
            let scoreLabelScale = 1.0;
            if (scoreBounceTimer > 0) {
                const bounceScale = 1 + Math.sin(scoreBounceTimer * (1/0.5) * Math.PI) * 0.5;
                scoreFontSize *= bounceScale;
                ctx.fillStyle = 'red';
            } else {
                ctx.fillStyle = 'black';
            }
            
            ctx.font = `${scoreFontSize}px Amanojaku`;
            const scoreNumberWidth = ctx.measureText(scoreNumberText).width;
            ctx.fillText(scoreNumberText, canvas.width - 20, 40);
            
            ctx.fillStyle = 'black';
            ctx.font = `bold ${24 * scoreLabelScale}px Amanojaku`;
            
            const scoreLabel = 'SCORE: ';
            const scoreLabelWidth = ctx.measureText(scoreLabel).width;
            const scoreX = canvas.width - 20 - scoreNumberWidth;
            
            ctx.fillText(scoreLabel, scoreX, 40);

            ctx.textAlign = 'left';
            if (teleportCharges > 0 && images.teleportLogo && images.teleportLogo.complete && images.teleportLogo.naturalWidth > 0) {
                ctx.drawImage(images.teleportLogo, 20, 15, 40, 40);

                let teleportFontSize = 30;
                if(teleportBounceTimer > 0) {
                    const bounceScale = 1 + Math.sin(teleportBounceTimer * Math.PI) * 0.5;
                    teleportFontSize *= bounceScale;
                    ctx.fillStyle = `hsl(${ (1 - teleportBounceTimer) * 360 }, 100%, 50%)`;
                } else {
                    ctx.fillStyle = 'black';
                }

                ctx.font = `${teleportFontSize}px Amanojaku`;
                ctx.fillText('x', 65, 45);
                const x_width = ctx.measureText('x').width;

                ctx.font = `bold ${teleportFontSize}px "Segoe UI"`;
                ctx.fillText(teleportCharges, 65 + x_width, 45);
            }
            ctx.restore();
            ctx.textAlign = 'center';
        }

        function drawEndScreens() {
            if (gameOver) {
                ctx.fillStyle = `rgba(0, 0, 0, ${0.7 * gameOverFade})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.globalAlpha = Math.max(0, gameOverTextFade);
                ctx.fillStyle = `rgba(255, 255, 255, ${0.7 * gameOverFade})`;
                ctx.font = '70px Amanojaku';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 20);
                ctx.restore();

                if (canRestart) {
                    if (isShareMenuOpen) {
                        ctx.save();
                        ctx.globalAlpha = (1 - gameOverTextFade) * gameOverFade;
                        ctx.fillStyle = `rgba(255, 255, 255, ${1 * gameOverFade})`;
                        ctx.font = 'bold 24px "Segoe UI"';
                        ctx.fillText('Share your High Score!', canvas.width / 2, shareButton.y - 50);
                        ctx.restore();
                    }

                    ctx.fillStyle = `rgba(255, 255, 255, ${1 * gameOverFade})`;
                    ctx.font = 'bold 20px "Segoe UI"';
                    ctx.fillText(isMobile ? 'Tap to restart' : 'press SPACE to restart', canvas.width / 2, canvas.height / 2 + 20);
                    drawShareButton();
                    if (isShareMenuOpen) drawSocialShareButtons();
                }
            }
            if (gameWon) {
                ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.globalAlpha = Math.max(0, gameOverTextFade);
                ctx.fillStyle = 'black';
                ctx.font = '50px Amanojaku';
                ctx.fillText('YOU WIN', canvas.width / 2, canvas.height / 2 - 20);
                ctx.restore();
                if (canRestart) {
                    if (isShareMenuOpen) {
                        ctx.save();
                        ctx.globalAlpha = (1 - gameOverTextFade);
                        ctx.fillStyle = 'black';
                        ctx.font = 'bold 24px "Segoe UI"';
                        ctx.fillText('Share your High Score!', canvas.width / 2, shareButton.y - 50);
                        ctx.restore();
                    }
                    ctx.font = 'bold 20px "Segoe UI"';
                    ctx.fillText(isMobile ? 'Tap to restart' : 'press SPACE to restart', canvas.width / 2, canvas.height / 2 + 20);
                    drawShareButton();
                    if (isShareMenuOpen) drawSocialShareButtons();
                }
            }
        }
        
        function drawRestartButton() {
            if (images.button && images.button.complete && images.button.naturalWidth > 0) {
                const stateData = animationStates.button;
                const columns = stateData.columns;
                const frameX = restartButton.frame % columns;
                const frameY = Math.floor(restartButton.frame / columns);
                const sourceX = frameX * stateData.spriteWidth;
                const sourceY = frameY * stateData.spriteHeight;
                
                let drawWidth = restartButton.width;
                let drawHeight = restartButton.height;
                let drawX = restartButton.x;
                let drawY = restartButton.y;

                if (restartButton.isPressed) {
                    const scale = 0.9;
                    drawWidth *= scale;
                    drawHeight *= scale;
                    drawX += (restartButton.width - drawWidth) / 2;
                    drawY += (restartButton.height - drawHeight) / 2;
                }

                ctx.drawImage(images.button, sourceX, sourceY, stateData.spriteWidth, stateData.spriteHeight, drawX, drawY, drawWidth, drawHeight);
            }
        }
        
        function drawShareButton() {
            if (images.share && images.share.complete && images.share.naturalWidth > 0) {
                const btn = shareButton;
                const stateData = animationStates.share;
                const columns = stateData.columns;
                const frameX = btn.frame % columns;
                const frameY = Math.floor(btn.frame / columns);
                const sourceX = frameX * stateData.spriteWidth;
                const sourceY = frameY * stateData.spriteHeight;

                const w = btn.width * btn.scale;
                const h = btn.height * btn.scale;
                const x = btn.x - (w - btn.width) / 2;
                const y = btn.y - (h - btn.height) / 2;
                
                ctx.drawImage(images.share, sourceX, sourceY, stateData.spriteWidth, stateData.spriteHeight, x, y, w, h);
            }
        }

        function drawSocialShareButtons() {
            socialButtons.forEach(btn => {
                if (btn.visible && images[btn.imageKey] && images[btn.imageKey].complete) {
                    const stateData = animationStates.shareIcon;
                    const columns = stateData.columns;
                    const frameX = btn.frame % columns;
                    const frameY = Math.floor(btn.frame / columns);
                    const sourceX = frameX * stateData.spriteWidth;
                    const sourceY = frameY * stateData.spriteHeight;

                    const w = btn.width * btn.scale;
                    const h = btn.height * btn.scale;
                    const x = btn.x - (w - btn.width) / 2;
                    const y = btn.y - (h - btn.height) / 2;

                    ctx.drawImage(images[btn.imageKey], sourceX, sourceY, stateData.spriteWidth, stateData.spriteHeight, x, y, w, h);
                }
            });
        }

        function drawPreMenu() {
            if ((isMobile && images.tap && images.tap.complete && images.tap.naturalWidth > 0) || (!isMobile && images.space && images.space.complete && images.space.naturalWidth > 0)) {
                const preMenuImage = isMobile ? images.tap : images.space;
                const stateData = isMobile ? animationStates.tap : animationStates.space;
                const columns = stateData.columns;
                const frameX = preMenuFrame % columns;
                const frameY = Math.floor(preMenuFrame / columns);
                const sourceX = frameX * stateData.spriteWidth;
                const sourceY = frameY * stateData.spriteHeight;
                ctx.drawImage(preMenuImage, sourceX, sourceY, stateData.spriteWidth, stateData.spriteHeight, 0, 0, canvas.width, canvas.height);
            }
        }

        function drawMenu() {
            let currentImage;
            let stateData;
            if (menuState === 'intro') {
                currentImage = images.menuIntro;
                stateData = animationStates.menuIntro;
            } else if (menuState === 'loop') {
                currentImage = images.menuLoop;
                stateData = animationStates.menuLoop;
            } else if (menuState === 'outro') {
                currentImage = images.menuOutro;
                stateData = animationStates.menuOutro;
            }

            if (currentImage && currentImage.complete && currentImage.naturalWidth > 0) {
                const columns = stateData.columns;
                const frameX = menuFrame % columns;
                const frameY = Math.floor(menuFrame / columns);
                const sourceX = frameX * stateData.spriteWidth;
                const sourceY = frameY * stateData.spriteHeight;
                ctx.drawImage(currentImage, sourceX, sourceY, stateData.spriteWidth, stateData.spriteHeight, 0, 0, canvas.width, canvas.height);
            }
        }

        function drawScrollButton() {
            if (images.scroll && images.scroll.complete && images.scroll.naturalWidth > 0) {
                const btn = scrollButton;
                const stateData = animationStates.scroll;
                const columns = stateData.columns;
                const frameX = btn.frame % columns;
                const frameY = Math.floor(btn.frame / columns);
                const sourceX = frameX * stateData.spriteWidth;
                const sourceY = frameY * stateData.spriteHeight;

                const w = btn.width * btn.scale;
                const h = btn.height * btn.scale;
                const x = btn.x - (w - btn.width) / 2;
                const y = btn.y - (h - btn.height) / 2;

                ctx.drawImage(images.scroll, sourceX, sourceY, stateData.spriteWidth, stateData.spriteHeight, x, y, w, h);
            }
        }

        function drawInfoBox() {
            if (isInfoBoxVisible) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                const boxWidth = canvas.width * 0.6;
                const boxHeight = canvas.height * 0.8;
                const boxX = (canvas.width - boxWidth) / 2;
                const boxY = (canvas.height - boxHeight) / 2;
                ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';

                // Title
                ctx.font = '30px Amanojaku';
                ctx.fillText('GAME CONTROLS', canvas.width / 2, boxY + 60);

                // Body Text
                ctx.font = '20px "Segoe UI"';
                const lineHeight = 30;
                let currentY = boxY + 120;
                ctx.fillText('JUMP - Space ; Arrow Up ; Tap once', canvas.width / 2, currentY);
                currentY += lineHeight;
                ctx.fillText('CROUCH - S ; Arrow Down ; Tap and hold', canvas.width / 2, currentY);
            }
        }
        
        function drawRotateCanvas() {
            if (images.rotate && images.rotate.complete && images.rotate.naturalWidth > 0) {
                const stateData = animationStates.rotate;
                const columns = stateData.columns;
                const frameX = rotateFrame % columns;
                const frameY = Math.floor(rotateFrame / columns);
                const sourceX = frameX * stateData.spriteWidth;
                const sourceY = frameY * stateData.spriteHeight;
                rotateCtx.clearRect(0,0, rotateCanvas.width, rotateCanvas.height);
                rotateCtx.drawImage(images.rotate, sourceX, sourceY, stateData.spriteWidth, stateData.spriteHeight, 0, 0, rotateCanvas.width, rotateCanvas.height);
            }
        }

        function drawVolumeButton() {
            if (images.volume && images.volume.complete && images.volume.naturalWidth > 0) {
                ctx.save();
                ctx.globalAlpha = volumeButton.opacity;
                const stateData = animationStates.volume;
                const columns = stateData.columns;
                const frameX = volumeButton.frame % columns;
                const frameY = Math.floor(volumeButton.frame / columns);
                const sourceX = frameX * stateData.spriteWidth;
                const sourceY = frameY * stateData.spriteHeight;

                const w = volumeButton.width * volumeButton.scale;
                const h = volumeButton.height * volumeButton.scale;
                const x = volumeButton.x - (w - volumeButton.width) / 2;
                const y = volumeButton.y - (h - volumeButton.height) / 2;

                ctx.drawImage(images.volume, sourceX, sourceY, stateData.spriteWidth, stateData.spriteHeight, x, y, w, h);
                ctx.restore();
            }
        }

        function repositionUIElements() {
            restartButton.x = canvas.width - 130;
            restartButton.y = canvas.height - 130;

            volumeButton.x = canvas.width / 2 - 25;
            volumeButton.y = canvas.height - 70;

            scrollButton.x = canvas.width - 130;
            scrollButton.targetY = canvas.height - 130;

            shareButton.x = canvas.width / 2 + 275;
            shareButton.y = canvas.height / 2 - 80;
            
            const platforms = [
                { key: 'shareTelegram', action: shareOnTelegram },
                { key: 'shareReddit', action: shareOnReddit },
                { key: 'shareFacebook', action: shareOnFacebook },
                { key: 'shareWhatsApp', action: shareOnWhatsApp },
                { key: 'shareTwitter', action: shareOnTwitter }
            ];

            const socialButtonWidth = 70;
            const socialButtonGap = 20;

            const totalWidth = platforms.length * socialButtonWidth + (platforms.length - 1) * socialButtonGap;
            let startX = (canvas.width - totalWidth) / 2;

            socialButtons = platforms.map(p => ({
                x: startX,
                y: shareButton.y,
                width: socialButtonWidth,
                height: socialButtonWidth,
                scale: 0,
                visible: false,
                isAnimatingIn: false,
                animationDelay: 0,
                frame: 0,
                frameTimer: 0,
                imageKey: p.key,
                action: p.action,
            }));
            
            let currentX = startX;
            for(let i = socialButtons.length -1; i >= 0; i--){
                socialButtons[i].x = currentX;
                currentX += socialButtons[i].width + socialButtonGap;
            }


            if (menuState === 'pre-menu') {
                scrollButton.y = canvas.height + 50;
            }
        }

        // --- Game Initialization ---
        function mainLoop(currentTime) {
            if (!lastTime) lastTime = currentTime;
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            update(deltaTime);
            draw();
            drawRotateCanvas();
            
            requestAnimationFrame(mainLoop);
        }
        
        function initialDraw() {
            if (assetsLoaded < totalAssets) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'black';
                ctx.font = '20px "Segoe UI"';
                ctx.textAlign = 'center';
                ctx.fillText(`Loading... ${Math.round((assetsLoaded / totalAssets) * 100)}%`, canvas.width / 2, canvas.height / 2);
                requestAnimationFrame(initialDraw);
                return;
            }
            
            repositionUIElements();
            window.addEventListener('resize', repositionUIElements);

            lastTime = performance.now();
            mainLoop(lastTime);
        }

        preloadAssets();
        initialDraw();

    </script>
</body>
</html>

