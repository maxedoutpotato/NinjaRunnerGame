<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ninja Runner</title>
    <style>
        /* Define the custom font */
        @font-face {
            font-family: 'Amanojaku';
            src: url('Amanojaku Demo.otf') format('opentype');
        }

        /* Basic styling to center the game and make it look clean */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #282c34;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            flex-direction: column;
        }
        canvas {
            background-color: #f0f0f0;
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            /* This makes the canvas responsive */
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <script>
        // --- Canvas and Context Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Game Constants ---
        const GRAVITY = 2300;
        const JUMP_STRENGTH = -900;
        const PLAYER_SPRITE_WIDTH = 100;
        const PLAYER_SPRITE_HEIGHT = 100;
        const PLAYER_DRAW_WIDTH = 100;
        const PLAYER_DRAW_HEIGHT = 100;
        const DEBUG_MODE = false;
        
        // --- Physics vs Visuals ---
        const GROUND_HEIGHT_PHYSICS = 68;
        const VISUAL_GROUND_Y_OFFSET = -182;
        const VISUAL_GROUND_HEIGHT = 250;

        // --- Background Visuals ---
        const BG1_Y_POS = -540;
        const BG1_SCALE = 1.75;
        const BG2_Y_POS = -400;
        const BG2_SCALE = 1.3;

        // --- Scenery Visuals ---
        const MOUNTAIN_Y_POS = 40;
        const MOUNTAIN_AVG_SCALE = 0.8;
        const MOUNTAIN_SCALE_VARIANCE = 0.2;

        // --- Foreground Visuals ---
        const GRASS_Y_POS = 235;
        const GRASS_SPEED_MODIFIER = 1.5;
        const GRASS_SCALE = 2;

        // --- Player Effect Visuals ---
        const RUN_CLOUD_OFFSET_X = -70;
        const RUN_CLOUD_OFFSET_Y = 1;
        
        const PLAYER_GROUND_LEVEL = canvas.height - GROUND_HEIGHT_PHYSICS - PLAYER_DRAW_HEIGHT;

        const SHURIKEN_FLYING_HEIGHTS = [
            PLAYER_GROUND_LEVEL + PLAYER_DRAW_HEIGHT - 80,
            PLAYER_GROUND_LEVEL - 25,
            PLAYER_GROUND_LEVEL - 120
        ];

        // --- Game State ---
        let menuState = 'intro'; // 'intro', 'loop', 'outro', 'inactive'
        let gameStarted = false;
        let gameOver = false;
        let gameWon = false;
        let canRestart = false;
        let isRestarting = false;
        let restartFadeAmount = 0;
        let fadeDirection = 1;
        let groundX = 0;
        let bg1X = 0;
        let bg2X = 0;
        let grassX = 0;
        let gameSpeed = 300;
        const speedIncreaseRate = 0.3;
        let obstaclesArray = [];
        let sceneryArray = [];
        let effectsArray = [];
        let score = 0;
        let floatingScores = [];
        let scoreMilestone = 1;
        let scoreBounceTimer = 0; // For the 1000-point visual effect
        let teleportCharges = 0;
        let inversionAmount = 0;
        let inversionTarget = 0;
        let lastTime = 0;
        
        let menuFrame = 0;
        let menuFrameTimer = 0;

        // --- Bonus Spawn Tracking ---
        let bonusSpawns = {
            teleportGold: { '3000': 0, '9000': 0, '15000': 0 },
            bonusPoints: { '3000': 0, '6000': 0, '9000': 0, '12000': 0, '15000': 0, '19000': 0, '21000': 0 }
        };
        const bonusLimits = {
            teleportGold: { '3000': 2, '9000': 1, '15000': 1 },
            bonusPoints: { '3000': 4, '6000': 3, '9000': 2, '12000': 2, '15000': 3, '19000': 2, '21000': 2 }
        };

        // --- Player State ---
        let player = {
            x: 50, y: PLAYER_GROUND_LEVEL, width: PLAYER_DRAW_WIDTH, height: PLAYER_DRAW_HEIGHT,
            velocityY: 0, isJumping: false, isCrouching: false, isTeleporting: false,
            frame: 0, frameTimer: 0, state: 'run',
            hitbox: { offsetX: 20, offsetY: 18, width: 75, height: 65 },
            crouchHitbox: { offsetX: 10, offsetY: 40, width: 83, height: 45 }
        };

        // --- Animation Data ---
        const animationStates = {
            run: { frames: 10, columns: 4, frameDuration: 0.08 },
            jump: { frames: 23, columns: 5, frameDuration: 0.03},
            crouch: { frames: 10, columns: 4, frameDuration: 0.08 },
            fall: { frames: 26, columns: 6, frameDuration: 0.04 },
            teleport: { frames: 10, columns: 4, frameDuration: 0.035 },
            teleportGold: { frames: 20, columns: 5, frameDuration: 0.05 },
            shuriken: { frames: 6, columns: 3, frameDuration: 0.05 },
            runCloud: { frames: 24, columns: 5, frameDuration: 0.08},
            menuIntro: { frames: 28, columns: 4, frameDuration: 0.04, spriteWidth: 500, spriteHeight: 250 },
            menuLoop: { frames: 28, columns: 4, frameDuration: 0.1, spriteWidth: 500, spriteHeight: 250 },
            menuOutro: { frames: 28, columns: 4, frameDuration: 0.04, spriteWidth: 500, spriteHeight: 250 }
        };

        // --- Asset Loading ---
        const images = {};
        const sounds = {};
        const imageSources = {
            menuIntro: 'Assets/Menu/Intro.png',
            menuLoop: 'Assets/Menu/Loop.png',
            menuOutro: 'Assets/Menu/Outro.png',
            ground: 'Assets/Background/Ground.png',
            background1: 'Assets/Background/Background.1.png',
            background2: 'Assets/Background/Background.2.png',
            mountain: 'Assets/Background/background.mountain.png',
            grass: 'Assets/Background/Grass.png',
            run: 'Assets/Ninja.Main/Run.png',
            jump: 'Assets/Ninja.Main/Jump.png',
            crouch: 'Assets/Ninja.Main/Run.Crouch.png',
            fall: 'Assets/Ninja.Main/Fall.png',
            runCloud: 'Assets/Ninja.Main/Run.Cloud.png',
            teleport: 'Assets/Ninja.Main/Teleport.png',
            teleportLogo: 'Assets/Ninja.Main/Teleport.Logo.png',
            teleportGold: 'Assets/Ninja.Main/Teleport.Gold.png',
            shuriken: 'Assets/Obstacles/Shuriken.png',
            lantern: 'Assets/Obstacles/Lantern.png',
            rock: 'Assets/Obstacles/Rock.png',
            apple: 'Assets/Obstacles/Apple.png',
            carrot: 'Assets/Obstacles/Carrot.png'
        };
        const soundSources = {
            intro: 'Audio/Intro.mp3',
            gateClose: 'Audio/Gate.Close.mp3',
            start: 'Audio/Gong.Start.mp3', end: 'Audio/Gong.End.mp3', jump: 'Audio/Jump.mp3',
            roll: 'Audio/Roll.mp3', woosh: 'Audio/Woosh.mp3', kabuki: 'Audio/Kabuki.mp3',
            track: 'Audio/Track.mp3', fail: 'Audio/Fail.mp3', bell: 'Audio/Bell.mp3',
            teleport: 'Audio/Teleport.mp3', crouch: 'Audio/Crouch.mp3', eat: 'Audio/Eat.mp3', secret: 'Audio/Secret.mp3'
        };
        let assetsLoaded = 0;
        const totalAssets = Object.keys(imageSources).length + Object.keys(soundSources).length;

        function preloadAssets() {
            for (const key in imageSources) {
                images[key] = new Image();
                images[key].src = imageSources[key];
                images[key].onload = assetLoaded;
                images[key].onerror = () => console.error(`Failed to load image: ${imageSources[key]}`);
            }
            for (const key in soundSources) {
                sounds[key] = new Audio();
                sounds[key].src = soundSources[key];
                if (key === 'track' || key === 'intro') sounds[key].loop = true;
                sounds[key].oncanplaythrough = assetLoaded;
                sounds[key].onerror = () => console.error(`Failed to load sound: ${soundSources[key]}`);
            }
        }
        function assetLoaded() { assetsLoaded++; }

        // --- Input Handling ---
        document.addEventListener('keydown', function(event) {
            if (isRestarting) return;

            if (event.code === 'Space') {
                if ((gameOver || gameWon) && canRestart) {
                    isRestarting = true;
                    canRestart = false;
                    return;
                }
                if (!gameStarted) {
                    if (menuState === 'loop') {
                        menuState = 'outro';
                        menuFrame = 0;
                        menuFrameTimer = 0;
                        sounds.intro.pause();
                        sounds.intro.currentTime = 0;
                        startGame();
                    }
                } else if (!player.isJumping && !gameOver) {
                    player.isJumping = true;
                    player.velocityY = JUMP_STRENGTH;
                    player.state = 'jump';
                    player.frame = 0;
                    sounds.jump.currentTime = 0;
                    sounds.jump.play();
                    effectsArray.forEach(effect => { if(effect.startFading) effect.startFading() });
                }
            }
            
            if (gameOver || !gameStarted) return;

            if (event.code === 'KeyS' && !player.isJumping && !player.isCrouching) {
                player.isCrouching = true;
                player.state = 'crouch';
                sounds.crouch.currentTime = 0;
                sounds.crouch.play();
            }
        });
        document.addEventListener('keyup', function(event) {
            if (gameOver || isRestarting || !gameStarted) return;
            if (event.code === 'KeyS') {
                player.isCrouching = false;
                player.state = 'run';
            }
        });

        // --- All Classes (Full logic restored) ---
        class VisualEffect { constructor() { this.markedForDeletion = false; } }
        class TeleportEffect extends VisualEffect {
            constructor(x, y, followsPlayer) {
                super();
                this.image = images.teleport;
                this.spriteWidth = 100; this.spriteHeight = 100;
                this.width = 150; this.height = 150;
                this.x = x - (this.width - player.width) / 2;
                this.y = y - (this.height - player.height) / 2;
                this.frame = 0; this.frameTimer = 0;
                this.followsPlayer = followsPlayer;
            }
            update(deltaTime) {
                if (this.followsPlayer) {
                    this.x = player.x - (this.width - player.width) / 2;
                    this.y = player.y - (this.height - player.height) / 2;
                }
                this.frameTimer += deltaTime;
                const stateData = animationStates.teleport;
                if (this.frameTimer >= stateData.frameDuration) {
                    this.frame++; this.frameTimer = 0;
                }
                if (this.frame >= stateData.frames) {
                    this.markedForDeletion = true; player.isTeleporting = false;
                }
            }
            draw() {
                if (this.image.complete && this.image.naturalWidth > 0) {
                    const stateData = animationStates.teleport;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                }
            }
        }
        class RunCloud extends VisualEffect {
             constructor() {
                super();
                this.image = images.runCloud;
                this.spriteWidth = 100; this.spriteHeight = 100;
                this.width = 100; this.height = 100;
                this.x = player.x + RUN_CLOUD_OFFSET_X;
                this.y = player.y + RUN_CLOUD_OFFSET_Y;
                this.frame = 0; this.frameTimer = 0;
                this.opacity = 0; this.isFading = false;
            }
            startFading() { this.isFading = true; }
            activate() { this.isFading = false; this.x = player.x + RUN_CLOUD_OFFSET_X; }
            update(deltaTime) {
                if (this.isFading) {
                    if (this.opacity > 0) {
                        this.opacity -= 2 * deltaTime;
                        this.x -= gameSpeed * 0.2 * deltaTime;
                    }
                } else {
                    if (this.opacity < 1) this.opacity += 2 * deltaTime;
                    this.x = player.x + RUN_CLOUD_OFFSET_X;
                    this.y = player.y + RUN_CLOUD_OFFSET_Y;
                    this.frameTimer += deltaTime;
                    const stateData = animationStates.runCloud;
                    const dynamicFrameDuration = Math.max(0.02, stateData.frameDuration - (gameSpeed / 10000));
                    if (this.frameTimer >= dynamicFrameDuration) {
                        this.frame = (this.frame + 1) % stateData.frames;
                        this.frameTimer = 0;
                    }
                }
            }
            draw() {
                if (this.image.complete && this.image.naturalWidth > 0 && this.opacity > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    const stateData = animationStates.runCloud;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                    ctx.restore();
                }
            }
        }
        class FloatingScore {
            constructor(value, x, y, color = {r:0, g:100, b:0}) {
                this.value = value; this.x = x; this.y = y; this.color = color;
                this.opacity = 1; this.timer = 0;
            }
            update(deltaTime) {
                this.y -= 30 * deltaTime; this.timer += deltaTime;
                if (this.timer > 1.3) this.opacity -= 1.2 * deltaTime;
            }
            draw() {
                ctx.save();
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`;
                ctx.textAlign = 'center';
                
                const plusSign = '+';
                const valueText = this.value.toString();

                // Measure widths with respective fonts to center the whole text block
                ctx.font = 'bold 24px "Segoe UI"';
                const plusWidth = ctx.measureText(plusSign).width;
                ctx.font = '24px Amanojaku, "Segoe UI"';
                const valueWidth = ctx.measureText(valueText).width;
                const totalWidth = plusWidth + valueWidth;
                const startX = this.x - totalWidth / 2;

                // Draw '+' with standard font
                ctx.font = 'bold 24px "Segoe UI"';
                ctx.fillText(plusSign, startX + plusWidth / 2, this.y);
                
                // Draw the number with custom font
                ctx.font = '24px Amanojaku, "Segoe UI"';
                ctx.fillText(valueText, startX + plusWidth + valueWidth / 2, this.y);
                ctx.restore();
            }
        }
        class SceneryObject {
            constructor() { this.x = canvas.width + Math.random() * 50; }
            update(deltaTime) { this.x -= gameSpeed * this.speedModifier * deltaTime; }
        }
        class Mountain extends SceneryObject {
            constructor() {
                super();
                this.image = images.mountain;
                this.scale = (Math.random() * MOUNTAIN_SCALE_VARIANCE * 1.3) + (MOUNTAIN_AVG_SCALE - MOUNTAIN_SCALE_VARIANCE);
                this.width = this.image.width * this.scale;
                this.height = this.image.height * this.scale;
                this.y = MOUNTAIN_Y_POS; this.speedModifier = 0.06;
            }
            draw() {
                if (this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                }
            }
        }
        class Obstacle {
             constructor() { this.x = canvas.width; this.frame = 0; this.frameTimer = 0; this.passed = false; }
             update(deltaTime) { this.x -= gameSpeed * this.speedModifier * deltaTime; }
        }
        class Shuriken extends Obstacle {
            constructor() {
                super();
                this.image = images.shuriken;
                this.spriteWidth = 50; this.spriteHeight = 50;
                this.width = 70; this.height = 70;
                this.y = SHURIKEN_FLYING_HEIGHTS[Math.floor(Math.random() * SHURIKEN_FLYING_HEIGHTS.length)];
                this.speedModifier = 1.1; this.hitbox = { offsetX: 10, offsetY: 10, width: 50, height: 50 };
            }
            update(deltaTime) {
                super.update(deltaTime);
                this.frameTimer += deltaTime;
                const stateData = animationStates.shuriken;
                if (this.frameTimer >= stateData.frameDuration) {
                    this.frame = (this.frame + 1) % stateData.frames;
                    this.frameTimer = 0;
                }
            }
            draw() {
                if (this.image.complete && this.image.naturalWidth > 0) {
                    const stateData = animationStates.shuriken;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                    if (DEBUG_MODE) { ctx.strokeRect(this.x + this.hitbox.offsetX, this.y + this.hitbox.offsetY, this.hitbox.width, this.hitbox.height); }
                }
            }
        }
        class Lantern extends Obstacle {
            constructor() {
                super();
                this.image = images.lantern;
                this.width = 90; this.height = 90;
                this.y = PLAYER_GROUND_LEVEL + PLAYER_DRAW_HEIGHT - this.height - 1;
                this.speedModifier = 1.0;
                this.hitbox = { offsetX: 18, offsetY: 10, width: 55, height: 65 };
            }
             draw() {
                if (this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                    if (DEBUG_MODE) { ctx.strokeRect(this.x + this.hitbox.offsetX, this.y + this.hitbox.offsetY, this.hitbox.width, this.hitbox.height); }
                }
             }
        }
        class Rock extends Obstacle {
            constructor() {
                super();
                this.image = images.rock;
                this.width = 140; this.height = 130;
                this.y = PLAYER_GROUND_LEVEL + PLAYER_DRAW_HEIGHT - this.height + 20;
                this.speedModifier = 1.0;
                this.hitbox = { offsetX: 35, offsetY: 45 , width: 85, height: 60 };
            }
            draw() {
                 if (this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                    if (DEBUG_MODE) { ctx.strokeRect(this.x + this.hitbox.offsetX, this.y + this.hitbox.offsetY, this.hitbox.width, this.hitbox.height); }
                }
            }
        }
        class TeleportGold extends Obstacle {
            constructor() {
                super();
                this.image = images.teleportGold;
                this.spriteWidth = 80; this.spriteHeight = 80;
                this.width = 60; this.height = 60;
                this.y = SHURIKEN_FLYING_HEIGHTS[Math.floor(Math.random() * SHURIKEN_FLYING_HEIGHTS.length)];
                this.speedModifier = 1; this.hitbox = { offsetX: 0, offsetY: 0, width: 60, height: 60 };
            }
            update(deltaTime) {
                super.update(deltaTime);
                this.frameTimer += deltaTime;
                const stateData = animationStates.teleportGold;
                if (this.frameTimer >= stateData.frameDuration) {
                    this.frame = (this.frame + 1) % stateData.frames;
                    this.frameTimer = 0;
                }
            }
            draw() {
                if (this.image.complete && this.image.naturalWidth > 0) {
                    const stateData = animationStates.teleportGold;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                }
            }
        }
        class BonusPoints extends Obstacle {
            constructor() {
                super();
                this.image = Math.random() < 0.5 ? images.apple : images.carrot;
                this.width = 80; this.height = 80;
                this.y = SHURIKEN_FLYING_HEIGHTS[Math.floor(Math.random() * SHURIKEN_FLYING_HEIGHTS.length)];
                this.speedModifier = 1;
                this.hitbox = { offsetX: 0, offsetY: 0, width: 80, height: 80 };
            }
            draw() {
                if (this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                }
            }
        }

        function handleScenery(deltaTime) {
            sceneryArray.forEach(item => item.update(deltaTime));
            sceneryArray = sceneryArray.filter(item => item.x > -item.width);
            if (gameOver || isRestarting) return;
            const minMountainSpawnDistance = canvas.width;
            const mountainSpawnChance = 0.005;
            let canSpawnMountain = sceneryArray.length === 0 || sceneryArray[sceneryArray.length - 1].x < canvas.width - minMountainSpawnDistance;
            if (canSpawnMountain && Math.random() < mountainSpawnChance) {
                sceneryArray.push(new Mountain());
            }
        }
        function handleObstacles(deltaTime) {
            obstaclesArray.forEach(obstacle => obstacle.update(deltaTime));
            if (gameOver || isRestarting) return;
            const minSpawnDistance = canvas.width / 1.2;
            const spawnChance = 0.015;
            let canSpawn = (obstaclesArray.length === 0 && !isRestarting) || (obstaclesArray.length > 0 && obstaclesArray[obstaclesArray.length - 1].x < canvas.width - minSpawnDistance);
            if (canSpawn && Math.random() < spawnChance) {
                let currentMilestoneKey = '0';
                if (score < 3000) currentMilestoneKey = '3000';
                else if (score < 6000) currentMilestoneKey = '6000';
                else if (score < 9000) currentMilestoneKey = '9000';
                else if (score < 12000) currentMilestoneKey = '12000';
                else if (score < 15000) currentMilestoneKey = '15000';
                else if (score < 19000) currentMilestoneKey = '19000';
                else if (score < 21000) currentMilestoneKey = '21000';
                let bonusSpawned = false;
                if (bonusLimits.teleportGold[currentMilestoneKey] && bonusSpawns.teleportGold[currentMilestoneKey] < bonusLimits.teleportGold[currentMilestoneKey] && Math.random() < 0.15) {
                    obstaclesArray.push(new TeleportGold());
                    bonusSpawns.teleportGold[currentMilestoneKey]++;
                    bonusSpawned = true;
                } 
                else if (bonusLimits.bonusPoints[currentMilestoneKey] && bonusSpawns.bonusPoints[currentMilestoneKey] < bonusLimits.bonusPoints[currentMilestoneKey] && Math.random() < 0.25) {
                    obstaclesArray.push(new BonusPoints());
                    bonusSpawns.bonusPoints[currentMilestoneKey]++;
                    bonusSpawned = true;
                }
                if (!bonusSpawned) {
                    const obstacleType = Math.random();
                    if (obstacleType < 0.4) obstaclesArray.push(new Shuriken());
                    else if (Math.random() < 0.5) obstaclesArray.push(new Lantern());
                    else obstaclesArray.push(new Rock());
                }
            }
        }
        function addScore(points, color = {r:0, g:100, b:0}) {
            const oldScore = score;
            score += points;
            if (Math.floor(score / 1000) > Math.floor(oldScore / 1000)) {
                sounds.kabuki.play();
                scoreBounceTimer = 0.5; // Trigger the bounce effect for 0.5 seconds
            }
            if (score >= scoreMilestone * 3000) {
                resetGameForNextLevel();
                return true;
            }
            floatingScores.push(new FloatingScore(points, player.x + player.width / 2, player.y, color));
            return false;
        }
        function checkCollisionsAndScore() {
            if (gameOver) return;
            const playerHitbox = player.isCrouching ? player.crouchHitbox : player.hitbox;
            const px = player.x + playerHitbox.offsetX;
            const py = player.y + playerHitbox.offsetY;
            const pw = playerHitbox.width;
            const ph = playerHitbox.height;
            for (let i = obstaclesArray.length - 1; i >= 0; i--) {
                const obstacle = obstaclesArray[i];
                const ox = obstacle.x + obstacle.hitbox.offsetX;
                const oy = obstacle.y + obstacle.hitbox.offsetY;
                const ow = obstacle.hitbox.width;
                const oh = obstacle.hitbox.height;
                if (px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy) {
                    if (obstacle instanceof TeleportGold) {
                        teleportCharges++;
                        sounds.secret.currentTime = 0;
                        sounds.secret.play();
                        obstaclesArray.splice(i, 1);
                    } else if (obstacle instanceof BonusPoints) {
                        const points = Math.floor(Math.random() * 151) + 150;
                        const didReset = addScore(points, {r: 0, g: 100, b: 255});
                        sounds.eat.currentTime = 0;
                        sounds.eat.play();
                        obstaclesArray.splice(i, 1);
                        if (didReset) return;
                    } else if (teleportCharges > 0) {
                        teleportCharges--;
                        player.isTeleporting = true;
                        sounds.teleport.currentTime = 0;
                        sounds.teleport.play();
                        effectsArray.push(new TeleportEffect(player.x, player.y, player.isJumping));
                        obstaclesArray.splice(i, 1);
                    } else {
                        gameOver = true;
                        player.state = 'fall';
                        player.frame = 0;
                        sounds.end.play();
                        sounds.fail.play();
                        sounds.track.pause();
                        sounds.track.currentTime = 0;
                        setTimeout(() => { canRestart = true; }, 2000);
                    }
                }
                if (!obstacle.passed && obstacle.x + obstacle.width < player.x) {
                    obstacle.passed = true;
                    if (!(obstacle instanceof TeleportGold) && !(obstacle instanceof BonusPoints)) {
                        sounds.woosh.currentTime = 0;
                        sounds.woosh.play();
                        const points = 100;
                        const didReset = addScore(points);
                        if (didReset) return;
                    }
                }
            }
        }
        function resetGameForNextLevel() {
            gameSpeed = 300;
            obstaclesArray = [];
            floatingScores = [];
            sounds.bell.play();
            scoreMilestone++;
            if (score >= 21000) {
                gameWon = true;
                inversionTarget = 1;
                sounds.track.pause();
                setTimeout(() => { canRestart = true; }, 2000);
            } else if (scoreMilestone % 2 === 0) { // 3k, 9k, 15k...
                 inversionTarget = 1;
            } else { // 6k, 12k...
                 inversionTarget = 0;
            }
            if (!player.isJumping) {
                player.state = 'run';
                player.frame = 0;
            }
        }
        function update(deltaTime) {
            
            if (isRestarting) {
                restartFadeAmount += 2 * fadeDirection * deltaTime;
                if (restartFadeAmount >= 1 && fadeDirection === 1) {
                    fadeDirection = -1;
                    gameOver = false; gameWon = false; gameSpeed = 300; score = 0;
                    obstaclesArray = []; sceneryArray = []; effectsArray = []; floatingScores = [];
                    scoreMilestone = 1; teleportCharges = 0; inversionAmount = 0; inversionTarget = 0;
                    bonusSpawns = {
                        teleportGold: { '3000': 0, '9000': 0, '15000': 0 },
                        bonusPoints: { '3000': 0, '6000': 0, '9000': 0, '12000': 0, '15000': 0, '19000': 0, '21000': 0 }
                    };
                    player.y = PLAYER_GROUND_LEVEL; player.state = 'run'; player.frame = 0; player.frameTimer = 0;
                    effectsArray.push(new RunCloud());
                    sounds.track.currentTime = 0; sounds.track.play();
                }
                if (restartFadeAmount <= 0 && fadeDirection === -1) {
                    isRestarting = false; fadeDirection = 1;
                }
                return;
            }

            if (menuState !== 'inactive') {
                updateMenu(deltaTime);
            }
            if (!gameStarted) return;


            if (gameOver || gameWon) {
                if (gameSpeed > 0) gameSpeed -= 300 * deltaTime;
                else gameSpeed = 0;
                effectsArray.forEach(effect => { if(effect instanceof RunCloud) effect.startFading() });
            } else {
                gameSpeed += speedIncreaseRate * 60 * deltaTime;
            }

            if (scoreBounceTimer > 0) {
                scoreBounceTimer -= deltaTime;
            }

            const transitionSpeed = 1 / 4;
            if (inversionAmount < inversionTarget) {
                inversionAmount = Math.min(inversionTarget, inversionAmount + transitionSpeed * deltaTime);
            } else if (inversionAmount > inversionTarget) {
                inversionAmount = Math.max(inversionTarget, inversionAmount - transitionSpeed * deltaTime);
            }
            groundX -= gameSpeed * deltaTime;
            bg1X -= gameSpeed * 0.1 * deltaTime;
            bg2X -= gameSpeed * 0.03 * deltaTime;
            grassX -= gameSpeed * GRASS_SPEED_MODIFIER * deltaTime;
            
            const bg1_scaledWidth = images.background1 ? images.background1.width * BG1_SCALE : 0;
            const bg2_scaledWidth = images.background2 ? images.background2.width * BG2_SCALE : 0;
            const grass_scaledWidth = images.grass ? images.grass.width * GRASS_SCALE : 0;

            if (groundX <= -images.ground.width) groundX += images.ground.width;
            if (bg1_scaledWidth > 0 && bg1X <= -bg1_scaledWidth) bg1X += bg1_scaledWidth;
            if (bg2_scaledWidth > 0 && bg2X <= -bg2_scaledWidth) bg2X += bg2_scaledWidth;
            if (grass_scaledWidth > 0 && grassX <= -grass_scaledWidth) grassX += grass_scaledWidth;
            
            if (player.isJumping) {
                player.velocityY += GRAVITY * deltaTime;
                player.y += player.velocityY * deltaTime;
            }
            if (player.y > PLAYER_GROUND_LEVEL) {
                player.y = PLAYER_GROUND_LEVEL;
                if(player.isJumping) {
                    effectsArray.forEach(effect => { if(effect instanceof RunCloud) effect.activate() });
                }
                player.isJumping = false;
                player.velocityY = 0;
                if (!player.isCrouching && !gameOver) { player.state = 'run'; }
            }
            player.frameTimer += deltaTime;
            const stateData = animationStates[player.state];
            let dynamicFrameDuration = stateData.frameDuration;
            if (player.state === 'run' || player.state === 'crouch') {
                dynamicFrameDuration = Math.max(0.02, stateData.frameDuration - (gameSpeed / 10000));
            }
            if (player.frameTimer >= dynamicFrameDuration) {
                if (player.state === 'fall') {
                    if (player.frame < stateData.frames - 1) player.frame++;
                } else {
                    player.frame = (player.frame + 1) % stateData.frames;
                }
                player.frameTimer = 0;
            }
            effectsArray.forEach(effect => effect.update(deltaTime));
            effectsArray = effectsArray.filter(effect => !effect.markedForDeletion);
        }
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (menuState === 'intro' || menuState === 'loop') {
                drawMenu();
            } else {
                ctx.save();
                ctx.filter = `invert(${inversionAmount * 100}%)`;
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                if (images.background2 && images.background2.complete && images.background2.naturalWidth > 0) {
                    const scaledWidth = images.background2.width * BG2_SCALE;
                    const scaledHeight = (images.background2.naturalHeight / images.background2.naturalWidth) * scaledWidth;
                    ctx.drawImage(images.background2, Math.floor(bg2X), BG2_Y_POS, scaledWidth, scaledHeight);
                    ctx.drawImage(images.background2, Math.floor(bg2X + scaledWidth) - 1, BG2_Y_POS, scaledWidth, scaledHeight);
                    ctx.drawImage(images.background2, Math.floor(bg2X + scaledWidth * 2) - 2, BG2_Y_POS, scaledWidth, scaledHeight);
                }
                sceneryArray.forEach(item => item.draw());
                if (images.background1 && images.background1.complete && images.background1.naturalWidth > 0) {
                    const scaledWidth = images.background1.width * BG1_SCALE;
                    const scaledHeight = (images.background1.naturalHeight / images.background1.naturalWidth) * scaledWidth;
                    ctx.drawImage(images.background1, Math.floor(bg1X), BG1_Y_POS, scaledWidth, scaledHeight);
                    ctx.drawImage(images.background1, Math.floor(bg1X + scaledWidth) - 1, BG1_Y_POS, scaledWidth, scaledHeight);
                    ctx.drawImage(images.background1, Math.floor(bg1X + scaledWidth * 2) - 2, BG1_Y_POS, scaledWidth, scaledHeight);
                }
                if (images.ground.complete && images.ground.naturalWidth > 0) {
                    const groundY = canvas.height - GROUND_HEIGHT_PHYSICS + VISUAL_GROUND_Y_OFFSET;
                    ctx.drawImage(images.ground, Math.floor(groundX), groundY, images.ground.width, VISUAL_GROUND_HEIGHT);
                    ctx.drawImage(images.ground, Math.floor(groundX + images.ground.width) -1, groundY, images.ground.width, VISUAL_GROUND_HEIGHT);
                    ctx.drawImage(images.ground, Math.floor(groundX + images.ground.width * 2) -2, groundY, images.ground.width, VISUAL_GROUND_HEIGHT);
                }
                obstaclesArray.forEach(obstacle => obstacle.draw());
                effectsArray.forEach(effect => effect.draw());
                if (!player.isTeleporting) {
                    const playerStateData = animationStates[player.state];
                    if (images[player.state] && images[player.state].complete) {
                        const columns = playerStateData.columns;
                        const frameX = player.frame % columns;
                        const frameY = Math.floor(player.frame / columns);
                        const sourceX = frameX * PLAYER_SPRITE_WIDTH;
                        const sourceY = frameY * PLAYER_SPRITE_HEIGHT;
                        ctx.drawImage(images[player.state], sourceX, sourceY, PLAYER_SPRITE_WIDTH, PLAYER_SPRITE_HEIGHT, player.x, player.y, player.width, player.height);
                        if (DEBUG_MODE) {
                            ctx.strokeStyle = 'black';
                            ctx.lineWidth = 2;
                            let currentHitbox = player.isCrouching ? player.crouchHitbox : player.hitbox;
                            ctx.strokeRect(player.x + currentHitbox.offsetX, player.y + currentHitbox.offsetY, currentHitbox.width, currentHitbox.height);
                        }
                    }
                }
                if (images.grass && images.grass.complete && images.grass.naturalWidth > 0) {
                    const scaledWidth = images.grass.width * GRASS_SCALE;
                    const scaledHeight = images.grass.height * GRASS_SCALE;
                    ctx.drawImage(images.grass, Math.floor(grassX), GRASS_Y_POS, scaledWidth, scaledHeight);
                    ctx.drawImage(images.grass, Math.floor(grassX + scaledWidth) - 1, GRASS_Y_POS, scaledWidth, scaledHeight);
                    ctx.drawImage(images.grass, Math.floor(grassX + scaledWidth * 2) - 2, GRASS_Y_POS, scaledWidth, scaledHeight);
                }
                
                if (menuState === 'outro') {
                    drawMenu(); // Will only draw the outro frame
                }

                for (let i = floatingScores.length - 1; i >= 0; i--) {
                    floatingScores[i].update(1/60);
                    floatingScores[i].draw();
                    if (floatingScores[i].opacity <= 0) { floatingScores.splice(i, 1); }
                }
                
                // Draw Score with mixed fonts
                ctx.textAlign = 'right';
                const scoreNumberText = score.toString();
                
                let scoreFontSize = 30;
                if (scoreBounceTimer > 0) {
                    const bounceScale = 1 + Math.sin(scoreBounceTimer * (1/0.5) * Math.PI) * 0.5; // Pulse effect
                    scoreFontSize *= bounceScale;
                    ctx.fillStyle = 'red';
                } else {
                    ctx.fillStyle = 'black';
                }
                
                ctx.font = `${scoreFontSize}px Amanojaku, "Segoe UI"`;
                const scoreNumberWidth = ctx.measureText(scoreNumberText).width;
                ctx.fillText(scoreNumberText, canvas.width - 20, 40);
                
                ctx.fillStyle = 'black'; // Reset color for the label
                ctx.font = 'bold 24px "Segoe UI"';
                ctx.fillText('SCORE: ', canvas.width - 20 - scoreNumberWidth, 40);

                // Draw Teleport Counter with mixed fonts
                ctx.textAlign = 'left';
                if (teleportCharges > 0 && images.teleportLogo.complete) {
                    ctx.drawImage(images.teleportLogo, 20, 15, 40, 40);
                    ctx.font = '30px Amanojaku, "Segoe UI"';
                    ctx.fillText('x', 65, 45);
                    const x_width = ctx.measureText('x').width;

                    ctx.font = 'bold 30px "Segoe UI"';
                    ctx.fillText(teleportCharges, 65 + x_width, 45);
                }
                ctx.textAlign = 'center';

                if (gameOver) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.font = '40px Amanojaku, "Segoe UI"';
                    ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 20);
                    if (canRestart) {
                        ctx.font = 'bold 20px "Segoe UI"';
                        ctx.fillText('press space to restart', canvas.width / 2, canvas.height / 2 + 20);
                    }
                }
                if (gameWon) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'black';
                    ctx.font = '40px Amanojaku, "Segoe UI"';
                    ctx.fillText('YOU WIN', canvas.width / 2, canvas.height / 2 - 20);
                    if (canRestart) {
                        ctx.font = 'bold 20px "Segoe UI"';
                        ctx.fillText('Press SPACE to restart', canvas.width / 2, canvas.height / 2 + 20);
                    }
                }
                ctx.restore();
            }

            if (isRestarting) {
                ctx.fillStyle = `rgba(255, 255, 255, ${restartFadeAmount})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // --- Game/Menu Loops ---
        function updateMenu(deltaTime) {
            menuFrameTimer += deltaTime;
            let stateData;
            if (menuState === 'intro') stateData = animationStates.menuIntro;
            else if (menuState === 'loop') stateData = animationStates.menuLoop;
            else if (menuState === 'outro') stateData = animationStates.menuOutro;

            if (stateData && menuFrameTimer >= stateData.frameDuration) {
                menuFrame++;
                menuFrameTimer = 0;
                
                if (menuState === 'intro' && menuFrame >= stateData.frames) {
                    menuState = 'loop';
                    menuFrame = 0;
                } else if (menuState === 'loop' && menuFrame >= stateData.frames) {
                    menuFrame = 0; // Loop the animation
                } else if (menuState === 'outro' && menuFrame >= stateData.frames) {
                    menuState = 'inactive';
                    // The game has already started, so we just stop the menu logic
                }
            }
        }

        function drawMenu() {
            // This function is now used for all menu drawing
            let currentImage;
            let stateData;
            if (menuState === 'intro') {
                currentImage = images.menuIntro;
                stateData = animationStates.menuIntro;
            } else if (menuState === 'loop') {
                currentImage = images.menuLoop;
                stateData = animationStates.menuLoop;
            } else if (menuState === 'outro') {
                currentImage = images.menuOutro;
                stateData = animationStates.menuOutro;
            }

            if (currentImage && currentImage.complete && currentImage.naturalWidth > 0) {
                const columns = stateData.columns;
                const frameX = menuFrame % columns;
                const frameY = Math.floor(menuFrame / columns);
                const sourceX = frameX * stateData.spriteWidth;
                const sourceY = frameY * stateData.spriteHeight;
                if(menuState !== 'outro') ctx.clearRect(0, 0, canvas.width, canvas.height); // Don't clear if it's the outro
                ctx.drawImage(currentImage, sourceX, sourceY, stateData.spriteWidth, stateData.spriteHeight, 0, 0, canvas.width, canvas.height);
            }
        }

        function startGame() {
            gameStarted = true;
            sounds.start.play();
            sounds.roll.play();
            sounds.track.play();
            sounds.gateClose.play();
            effectsArray.push(new RunCloud());
        }

        function mainLoop(currentTime) {
            if (!lastTime) lastTime = currentTime;
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            if(gameStarted) {
                update(deltaTime);
                handleScenery(deltaTime);
                handleObstacles(deltaTime);
                checkCollisionsAndScore();
            } else {
                updateMenu(deltaTime);
            }
            
            draw();
            
            requestAnimationFrame(mainLoop);
        }
        
        function initialDraw() {
            if (assetsLoaded < totalAssets) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'black';
                ctx.font = '20px "Segoe UI"';
                ctx.textAlign = 'center';
                ctx.fillText(`Loading... ${Math.round((assetsLoaded / totalAssets) * 100)}%`, canvas.width / 2, canvas.height / 2);
                setTimeout(initialDraw, 50);
                return;
            }
            sounds.intro.play();
            sounds.gateClose.play();
            lastTime = performance.now();
            mainLoop(lastTime);
        }

        preloadAssets();
        initialDraw();

    </script>
</body>
</html>

