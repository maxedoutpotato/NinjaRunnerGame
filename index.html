<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ninja Runner</title>

    <!-- Open Graph Meta Tags for Link Previews -->
    <meta property="og:title" content="Ninja Runner Game" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://maxedoutpotato.github.io/NinjaRunnerGame/" />
    <meta property="og:image" content="https://maxedoutpotato.github.io/NinjaRunnerGame/Assets/Preview/preview.png" />
    <meta property="og:description" content="A fast-paced 2D endless runner. Jump and crouch to dodge obstacles and collect bonuses in this challenging ninja adventure!" />

    <style>
        /* Define the custom font */
        @font-face {
            font-family: 'Amanojaku';
            src: url('https://maxedoutpotato.github.io/NinjaRunnerGame/Amanojaku%20Demo.otf') format('opentype');
        }

        /* Basic styling to center the game and make it look clean */
        body, html {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
            margin: 0;
            background-color: #1a1a1a; /* Darker grey for letterboxing */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            flex-direction: column;
            overflow: hidden; /* Prevent scrolling on mobile */
        }
        canvas {
            background-color: #f0f0f0;
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            /* This makes the canvas responsive */
            width: 100%;
            height: 100%;
            object-fit: contain;
            max-height: 100vh;
            max-width: 100vw;
            cursor: default;
        }
        #rotate-message {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: #282c34;
            color: white;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 24px;
            z-index: 100;
        }
        @media (orientation: portrait) {
            #rotate-message {
                display: flex;
            }
            #gameCanvas {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="rotate-message">
        <canvas id="rotateCanvas" width="250" height="500"></canvas>
    </div>
    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <script>
        // --- Canvas and Context Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const rotateCanvas = document.getElementById('rotateCanvas');
        const rotateCtx = rotateCanvas.getContext('2d');

        // --- Device Detection ---
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // --- Game Constants ---
        const GRAVITY = 2300;
        const JUMP_STRENGTH = -900;
        const PLAYER_SPRITE_WIDTH = 100;
        const PLAYER_SPRITE_HEIGHT = 100;
        const PLAYER_DRAW_WIDTH = 100;
        const PLAYER_DRAW_HEIGHT = 100;
        const DEBUG_MODE = false; // Set to true to see hitboxes
        
        // --- Physics vs Visuals ---
        const GROUND_HEIGHT_PHYSICS = 68;
        const VISUAL_GROUND_Y_OFFSET = -182;
        const VISUAL_GROUND_HEIGHT = 250;

        // --- Background Visuals ---
        const BG1_Y_POS = -540;
        const BG1_SCALE = 1.75;
        const BG2_Y_POS = -400;
        const BG2_SCALE = 1.3;

        // --- Scenery Visuals ---
        const MOUNTAIN_Y_POS = 40;
        const MOUNTAIN_AVG_SCALE = 0.8;
        const MOUNTAIN_SCALE_VARIANCE = 0.2;

        // --- Foreground Visuals ---
        const GRASS_Y_POS = 235;
        const GRASS_SPEED_MODIFIER = 1.5;
        const GRASS_SCALE = 2;

        // --- Player Effect Visuals ---
        const RUN_CLOUD_OFFSET_X = -70;
        const RUN_CLOUD_OFFSET_Y = 1;
        
        const PLAYER_GROUND_LEVEL = canvas.height - GROUND_HEIGHT_PHYSICS - PLAYER_DRAW_HEIGHT;

        const SHURIKEN_FLYING_HEIGHTS = [
            PLAYER_GROUND_LEVEL + PLAYER_DRAW_HEIGHT - 80,
            PLAYER_GROUND_LEVEL - 25,
            PLAYER_GROUND_LEVEL - 120
        ];

        // --- Game State Management ---
        // By grouping related variables into objects, the code becomes cleaner and easier to manage.
        const gameState = {
            gameStarted: false,
            gameOver: false,
            gameOverFade: 0,
            gameWon: false,
            canRestart: false,
            isRestarting: false,
            isResetting: false,
            isRestartButtonAnimating: false,
            restartFadeAmount: 0,
            fadeDirection: 1,
            groundX: 0,
            bg1X: 0,
            bg2X: 0,
            grassX: 0,
            gameSpeed: 300,
            score: 0,
            scoreMilestone: 1,
            teleportCharges: 0,
            inversionAmount: 0,
            inversionTarget: 0,
        };

        const uiState = {
            menuState: 'pre-menu', // 'pre-menu', 'intro', 'loop', 'outro', 'inactive'
            menuFrame: 0,
            preMenuFrame: 0,
            rotateFrame: 0,
            audioUnlocked: false,
            isMuted: false,
            showPreMenuBehindIntro: false,
            isInfoBoxVisible: false,
        };

        const timers = {
            lastTime: 0,
            uiFadeInTimer: 0,
            scoreBounceTimer: 0,
            teleportBounceTimer: 0,
            menuFrameTimer: 0,
            preMenuFrameTimer: 0,
            rotateFrameTimer: 0,
            touchStartTime: 0,
        };
        
        const inputState = {
            isHoldingTouch: false,
            wantsToCrouch: false,
        };

        const collections = {
            obstaclesArray: [],
            sceneryArray: [],
            effectsArray: [],
            floatingScores: [],
        };

        // --- Bonus Spawn Tracking ---
        let bonusSpawns = {
            teleportGold: { '3000': 0, '9000': 0, '15000': 0 },
            bonusPoints: { '3000': 0, '6000': 0, '9000': 0, '12000': 0, '15000': 0, '18000': 0, '21000': 0 }
        };
        const bonusLimits = {
            teleportGold: { '3000': 2, '9000': 1, '15000': 1 },
            bonusPoints: { '3000': 4, '6000': 3, '9000': 2, '12000': 2, '15000': 3, '18000': 2, '21000': 2 }
        };

        // --- Player State ---
        let player = {
            x: 50, y: PLAYER_GROUND_LEVEL, width: PLAYER_DRAW_WIDTH, height: PLAYER_DRAW_HEIGHT,
            velocityY: 0, isJumping: false, isCrouching: false, isTeleporting: false,
            frame: 0, frameTimer: 0, state: 'run',
            hitbox: { offsetX: 20, offsetY: 20, width: 65, height: 40 },
            crouchHitbox: { offsetX: 10, offsetY: 50, width: 70, height: 30 }
        };
        
        // --- UI Button States ---
        let restartButton = {
            x: 0, y: 0, width: 120, height: 120,
            frame: 0, frameTimer: 0, isHovered: false
        };
        let volumeButton = {
            x: 0, y: 0, width: 50, height: 50,
            frame: 5, frameTimer: 0, isHovered: false, scale: 1, targetScale: 1,
            opacity: 0.4, targetOpacity: 0.4
        };
        let scrollButton = {
            x: 0, y: canvas.height,
            targetY: 0,
            width: 120, height: 120,
            frame: 0, frameTimer: 0, isAnimating: false, animationDirection: 1, scale: 1
        };

        // --- Animation Data ---
        const animationStates = {
            run: { frames: 10, columns: 4, frameDuration: 0.08 },
            jump: { frames: 23, columns: 5, frameDuration: 0.03},
            crouch: { frames: 10, columns: 4, frameDuration: 0.08 },
            fall: { frames: 26, columns: 6, frameDuration: 0.04 },
            teleport: { frames: 10, columns: 4, frameDuration: 0.035 },
            teleportGold: { frames: 20, columns: 5, frameDuration: 0.05 },
            shuriken: { frames: 6, columns: 3, frameDuration: 0.05 },
            runCloud: { frames: 24, columns: 5, frameDuration: 0.08},
            menuIntro: { frames: 28, columns: 4, frameDuration: 0.04, spriteWidth: 500, spriteHeight: 250 },
            menuLoop: { frames: 28, columns: 4, frameDuration: 0.1, spriteWidth: 500, spriteHeight: 250 },
            menuOutro: { frames: 28, columns: 4, frameDuration: 0.04, spriteWidth: 500, spriteHeight: 250 },
            button: { frames: 10, columns: 4, frameDuration: 0.05, spriteWidth: 80, spriteHeight: 80 },
            rotate: { frames: 28, columns: 7, frameDuration: 0.05, spriteWidth: 250, spriteHeight: 500 },
            tap: { frames: 28, columns: 4, frameDuration: 0.08, spriteWidth: 500, spriteHeight: 250 },
            space: { frames: 28, columns: 4, frameDuration: 0.08, spriteWidth: 500, spriteHeight: 250 },
            scroll: { frames: 14, columns: 4, frameDuration: 0.05, spriteWidth: 120, spriteHeight: 120 },
            volume: { frames: 6, columns: 3, frameDuration: 0.05, spriteWidth: 100, spriteHeight: 100 }
        };

        // --- Asset Loading ---
        const GITHUB_REPO_URL = 'https://maxedoutpotato.github.io/NinjaRunnerGame/';
        const images = {};
        const sounds = {};
        const imageSources = {
            menuIntro: `Assets/Menu/${isMobile ? 'Intro.mobile.png' : 'Intro.png'}`,
            menuLoop: `Assets/Menu/${isMobile ? 'Loop.mobile.png' : 'Loop.png'}`,
            menuOutro: `Assets/Menu/${isMobile ? 'Outro.mobile.png' : 'Outro.png'}`,
            button: 'Assets/Menu/Button.png',
            rotate: 'Assets/Menu/Rotate.png',
            tap: 'Assets/Menu/Tap.png',
            space: 'Assets/Menu/Space.png',
            ground: 'Assets/Background/Ground.png',
            background1: 'Assets/Background/Background.1.png',
            background2: 'Assets/Background/Background.2.png',
            mountain: 'Assets/Background/background.mountain.png',
            grass: 'Assets/Background/Grass.png',
            run: 'Assets/Ninja.Main/Run.png',
            jump: 'Assets/Ninja.Main/Jump.png',
            crouch: 'Assets/Ninja.Main/Run.Crouch.png',
            fall: 'Assets/Ninja.Main/Fall.png',
            runCloud: 'Assets/Ninja.Main/Run.Cloud.png',
            teleport: 'Assets/Ninja.Main/Teleport.png',
            teleportLogo: 'Assets/Ninja.Main/Teleport.Logo.png',
            teleportGold: 'Assets/Ninja.Main/Teleport.Gold.png',
            shuriken: 'Assets/Obstacles/Shuriken.png',
            lantern: 'Assets/Obstacles/Lantern.png',
            rock: 'Assets/Obstacles/Rock.png',
            apple: 'Assets/Obstacles/Apple.png',
            carrot: 'Assets/Obstacles/Carrot.png',
            scroll: 'Assets/Menu/Scroll.png',
            volume: 'Assets/Menu/Volume.png'
        };
        const soundSources = {
            intro: 'Audio/Intro.mp3',
            gateClose: 'Audio/Gate.Close.mp3',
            gecko: 'Audio/Gecko.mp3',
            start: 'Audio/Gong.Start.mp3', end: 'Audio/Gong.End.mp3', jump: 'Audio/Jump.mp3',
            roll: 'Audio/Roll.mp3', woosh: 'Audio/Woosh.mp3', kabuki: 'Audio/Kabuki.mp3',
            track: 'Audio/Track.mp3', fail: 'Audio/Fail.mp3', bell: 'Audio/Bell.mp3',
            teleport: 'Audio/Teleport.mp3', crouch: 'Audio/Crouch.mp3', eat: 'Audio/Eat.mp3', secret: 'Audio/Secret.mp3',
            bounce: 'Audio/Bounce.mp3'
        };
        let assetsLoaded = 0;
        const totalAssets = Object.keys(imageSources).length + Object.keys(soundSources).length;

        function assetLoadCallback(type, src) {
            if (type === 'error') {
                console.warn(`Failed to load asset, but continuing: ${src}`);
            }
            assetsLoaded++;
        }

        function preloadAssets() {
            for (const key in imageSources) {
                images[key] = new Image();
                const src = GITHUB_REPO_URL + imageSources[key];
                images[key].src = src;
                images[key].onload = () => assetLoadCallback('success', src);
                images[key].onerror = () => assetLoadCallback('error', src);
            }
            for (const key in soundSources) {
                sounds[key] = new Audio();
                const src = GITHUB_REPO_URL + soundSources[key];
                sounds[key].src = src;
                if (key === 'track' || key === 'intro' || key === 'gecko') sounds[key].loop = true;
                sounds[key].addEventListener('canplaythrough', () => assetLoadCallback('success', src), { once: true });
                sounds[key].onerror = () => assetLoadCallback('error', src);
            }
        }

        // --- Input Handling ---
        function handleJump() {
            if (!player.isJumping && !gameState.gameOver) {
                inputState.wantsToCrouch = false;
                player.isJumping = true;
                player.velocityY = JUMP_STRENGTH;
                player.state = 'jump';
                player.frame = 0;
                sounds.jump.currentTime = 0;
                sounds.jump.play();
                collections.effectsArray.forEach(effect => { if(effect.startFading) effect.startFading() });
            }
        }

        function handleCrouchStart() {
            if (player.isJumping) {
                inputState.wantsToCrouch = true;
                return;
            }
            if (gameState.gameStarted && !player.isJumping && !player.isCrouching) {
                player.isCrouching = true;
                player.state = 'crouch';
                sounds.crouch.currentTime = 0;
                sounds.crouch.play();
            }
        }

        function handleCrouchEnd() {
            inputState.wantsToCrouch = false;
            if (player.isCrouching) {
                player.isCrouching = false;
                player.state = 'run';
            }
        }

        document.addEventListener('keydown', function(event) {
            if (gameState.isRestarting || gameState.isResetting || gameState.isRestartButtonAnimating) return;

            if (event.code === 'Space' || event.code === 'ArrowUp') {
                 if (uiState.menuState === 'pre-menu') {
                      unlockAudio();
                      return;
                 }
                if ((gameState.gameOver || gameState.gameWon) && gameState.canRestart) {
                    gameState.isRestarting = true;
                    gameState.canRestart = false;
                    return;
                }
                if (!gameState.gameStarted) {
                    if (uiState.menuState === 'loop') {
                        uiState.menuState = 'outro';
                        uiState.menuFrame = 0;
                        timers.menuFrameTimer = 0;
                        sounds.intro.pause();
                        sounds.intro.currentTime = 0;
                        startGame();
                    }
                } else {
                    handleJump();
                }
            }
            
            if (gameState.gameOver || !gameState.gameStarted) return;

            if ((event.code === 'KeyS' || event.code === 'ArrowDown')) {
                handleCrouchStart();
            }
        });
        document.addEventListener('keyup', function(event) {
            if (gameState.gameOver || gameState.isRestarting || !gameState.gameStarted || gameState.isResetting) return;
            if (event.code === 'KeyS' || event.code === 'ArrowDown') {
                handleCrouchEnd();
            }
        });

        // --- Mouse/Touch Controls ---
        function getScaledCoordinates(evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            let clientX = 0;
            let clientY = 0;
            
            if (evt.type.startsWith('touch')) {
                 if (evt.changedTouches && evt.changedTouches[0]) {
                    clientX = evt.changedTouches[0].clientX;
                    clientY = evt.changedTouches[0].clientY;
                }
            } else {
                clientX = evt.clientX || 0;
                clientY = evt.clientY || 0;
            }
            
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }
        
        canvas.addEventListener('mousemove', (evt) => {
            const mousePos = getScaledCoordinates(evt);
            if (!mousePos) return;

            const volBtn = volumeButton;
            const volBtnPadding = 10;
            if (mousePos.x >= volBtn.x - volBtnPadding && mousePos.x <= volBtn.x + volBtn.width + volBtnPadding &&
                mousePos.y >= volBtn.y - volBtnPadding && mousePos.y <= volBtn.y + volBtn.height + volBtnPadding) {
                if (!volBtn.isHovered) {
                    volBtn.isHovered = true;
                    volBtn.targetScale = 1.4;
                    volBtn.targetOpacity = 1.0;
                }
            } else {
                if (volBtn.isHovered) {
                    volBtn.isHovered = false;
                    volBtn.targetScale = 1.0;
                    volBtn.targetOpacity = 0.4;
                }
            }

            if (!gameState.canRestart) {
                canvas.style.cursor = 'default';
                return;
            };
            const isHoveringRestart = (mousePos.x >= restartButton.x && mousePos.x <= restartButton.x + restartButton.width &&
                mousePos.y >= restartButton.y && mousePos.y <= restartButton.y + restartButton.height);

            if (isHoveringRestart && !restartButton.isHovered) {
                restartButton.isHovered = true;
                canvas.style.cursor = 'pointer';
                if(sounds.gecko) {
                    sounds.gecko.currentTime = 0;
                    sounds.gecko.play();
                }
            } else if (!isHoveringRestart && restartButton.isHovered) {
                restartButton.isHovered = false;
                canvas.style.cursor = 'default';
                 if(sounds.gecko) {
                    sounds.gecko.pause();
                }
            }
        });

        function handleCanvasRelease(pos) {
             if (uiState.isInfoBoxVisible) {
                uiState.isInfoBoxVisible = false;
                scrollButton.isAnimating = true;
                scrollButton.animationDirection = -1;
                return true;
            }

            const volBtn = volumeButton;
            const volBtnPadding = isMobile ? 30 : 10;
            if (pos.x >= volBtn.x - volBtnPadding && pos.x <= volBtn.x + volBtn.width + volBtnPadding &&
                pos.y >= volBtn.y - volBtnPadding && pos.y <= volBtn.y + volBtn.height + volBtnPadding) {
                toggleMute();
                if (isMobile) {
                    volBtn.targetScale = 1.4;
                    volBtn.targetOpacity = 1.0;
                    setTimeout(() => {
                        if (!volBtn.isHovered) {
                            volBtn.targetScale = 1.0;
                            volBtn.targetOpacity = 0.4;
                        }
                    }, 150);
                }
                return true;
            }

            const restartBtnPadding = isMobile ? 30 : 0;
            if (gameState.canRestart && (gameState.gameOver || gameState.gameWon) &&
                 pos.x >= restartButton.x - restartBtnPadding && pos.x <= restartButton.x + restartButton.width + restartBtnPadding &&
                 pos.y >= restartButton.y - restartBtnPadding && pos.y <= restartButton.y + restartButton.height + restartBtnPadding) {
                 
                 if (isMobile) {
                    if (!gameState.isRestartButtonAnimating) {
                        gameState.isRestartButtonAnimating = true;
                        restartButton.frame = 0; 
                        sounds.gecko.currentTime = 0;
                        sounds.gecko.play();
                        gameState.canRestart = false; 
                    }
                } else { // PC logic
                    gameState.isResetting = true;
                    uiState.menuState = 'intro';
                    uiState.menuFrame = 0;
                    timers.menuFrameTimer = 0;
                    gameState.canRestart = false;
                    sounds.gateClose.play();
                    if(sounds.gecko) sounds.gecko.pause();
                }
                return true;
            }

            const scrollBtn = scrollButton;
            const scrollBtnPadding = isMobile ? 30 : 0;
            if (uiState.menuState === 'loop' &&
                pos.x >= scrollBtn.x - scrollBtnPadding && pos.x <= scrollBtn.x + scrollBtn.width + scrollBtnPadding &&
                pos.y >= scrollBtn.y - scrollBtnPadding && pos.y <= scrollBtn.y + scrollBtn.height + scrollBtnPadding) {
                uiState.isInfoBoxVisible = true;
                scrollButton.isAnimating = true;
                scrollButton.animationDirection = 1;
                return true;
            }

            return false;
        }

        canvas.addEventListener('mousedown', (evt) => {
            handleCanvasRelease(getScaledCoordinates(evt));
        });

        canvas.addEventListener('mouseup', (evt) => {
             // handleCanvasRelease is now in mousedown for PC, this can be empty
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState.isRestarting || gameState.isResetting || gameState.isRestartButtonAnimating) return;
            timers.touchStartTime = Date.now();
            inputState.isHoldingTouch = true;
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (gameState.isRestarting || gameState.isResetting || gameState.isRestartButtonAnimating) return;
            
            const touchPos = getScaledCoordinates(e);
            if (!touchPos) return;

            if (handleCanvasRelease(touchPos)) {
                inputState.isHoldingTouch = false;
                timers.touchStartTime = 0;
                return;
            }
            inputState.isHoldingTouch = false;

            if (uiState.menuState === 'pre-menu') {
                unlockAudio();
                return;
            }

            if ((gameState.gameOver || gameState.gameWon) && gameState.canRestart) {
                gameState.isRestarting = true;
                gameState.canRestart = false;
                return;
            }
            
            const touchDuration = Date.now() - timers.touchStartTime;
            if (gameState.gameStarted && touchDuration > 0) { 
                if (touchDuration < 250) handleJump();
                handleCrouchEnd();
            } else if (!gameState.gameStarted && uiState.menuState === 'loop') {
                uiState.menuState = 'outro';
                uiState.menuFrame = 0;
                timers.menuFrameTimer = 0;
                sounds.intro.pause();
                sounds.intro.currentTime = 0;
                startGame();
            }
            timers.touchStartTime = 0;
        }, { passive: false });

        // --- Sound Utility ---
        function unlockAudio() {
            if (uiState.audioUnlocked) return;
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            for (const key in sounds) {
                sounds[key].play().then(() => {
                    sounds[key].pause();
                    sounds[key].currentTime = 0;
                }).catch(e => {});
            }
            uiState.audioUnlocked = true;
            uiState.showPreMenuBehindIntro = true;
            
            setTimeout(() => {
                uiState.menuState = 'intro'; 
                sounds.intro.play();
                sounds.gateClose.play();
            }, 50);
        }

        function toggleMute() {
            uiState.isMuted = !uiState.isMuted;
            for (const key in sounds) {
                sounds[key].muted = uiState.isMuted;
            }
        }

        // --- All Classes (Full logic restored) ---
        class VisualEffect { constructor() { this.markedForDeletion = false; } }
        class TeleportEffect extends VisualEffect {
            constructor(x, y, followsPlayer) {
                super();
                this.image = images.teleport;
                this.spriteWidth = 100; this.spriteHeight = 100;
                this.width = 150; this.height = 150;
                this.x = x - (this.width - player.width) / 2;
                this.y = y - (this.height - player.height) / 2;
                this.frame = 0; this.frameTimer = 0;
                this.followsPlayer = followsPlayer;
            }
            update(deltaTime) {
                if (this.followsPlayer) {
                    this.x = player.x - (this.width - player.width) / 2;
                    this.y = player.y - (this.height - player.height) / 2;
                }
                this.frameTimer += deltaTime;
                const stateData = animationStates.teleport;
                if (this.frameTimer >= stateData.frameDuration) {
                    this.frame++; this.frameTimer = 0;
                }
                if (this.frame >= stateData.frames) {
                    this.markedForDeletion = true; player.isTeleporting = false;
                }
            }
            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    const stateData = animationStates.teleport;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                }
            }
        }
        class RunCloud extends VisualEffect {
             constructor() {
                super();
                this.image = images.runCloud;
                this.spriteWidth = 100; this.spriteHeight = 100;
                this.width = 100; this.height = 100;
                this.x = player.x + RUN_CLOUD_OFFSET_X;
                this.y = player.y + RUN_CLOUD_OFFSET_Y;
                this.frame = 0; this.frameTimer = 0;
                this.opacity = 0; this.isFading = false;
            }
            startFading() { this.isFading = true; }
            activate() { this.isFading = false; this.x = player.x + RUN_CLOUD_OFFSET_X; }
            update(deltaTime) {
                if (this.isFading) {
                    if (this.opacity > 0) {
                        this.opacity -= 2 * deltaTime;
                        this.x -= gameState.gameSpeed * 0.2 * deltaTime;
                    }
                } else {
                    if (this.opacity < 1) this.opacity += 2 * deltaTime;
                    this.x = player.x + RUN_CLOUD_OFFSET_X;
                    this.y = player.y + RUN_CLOUD_OFFSET_Y;
                    this.frameTimer += deltaTime;
                    const stateData = animationStates.runCloud;
                    const dynamicFrameDuration = Math.max(0.02, stateData.frameDuration - (gameState.gameSpeed / 10000));
                    if (this.frameTimer >= dynamicFrameDuration) {
                        this.frame = (this.frame + 1) % stateData.frames;
                        this.frameTimer = 0;
                    }
                }
            }
            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0 && this.opacity > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    const stateData = animationStates.runCloud;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                    ctx.restore();
                }
            }
        }
        class FloatingScore {
            constructor(value, x, y, color = {r:0, g:100, b:0}) {
                this.value = value; this.x = x; this.y = y; this.color = color;
                this.opacity = 1; this.timer = 0;
            }
            update(deltaTime) {
                this.y -= 30 * deltaTime; this.timer += deltaTime;
                if (this.timer > 1.3) this.opacity -= 1.2 * deltaTime;
            }
            draw() {
                ctx.save();
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`;
                ctx.textAlign = 'center';
                
                const plusSign = '+';
                const valueText = this.value.toString();

                ctx.font = 'bold 24px "Segoe UI"';
                const plusWidth = ctx.measureText(plusSign).width;
                ctx.font = '24px Amanojaku, "Segoe UI"';
                const valueWidth = ctx.measureText(valueText).width;
                const totalWidth = plusWidth + valueWidth;
                const startX = (this.x - totalWidth / 2) + 15; // Shifted right

                ctx.font = 'bold 24px "Segoe UI"';
                ctx.fillText(plusSign, startX + plusWidth / 2, this.y);
                
                ctx.font = '24px Amanojaku, "Segoe UI"';
                ctx.fillText(valueText, startX + plusWidth + valueWidth / 2, this.y);
                ctx.restore();
            }
        }
        class SceneryObject {
            constructor() { this.x = canvas.width + Math.random() * 50; }
            update(deltaTime) { this.x -= gameState.gameSpeed * this.speedModifier * deltaTime; }
        }
        class Mountain extends SceneryObject {
            constructor() {
                super();
                this.image = images.mountain;
                this.scale = (Math.random() * MOUNTAIN_SCALE_VARIANCE * 1.3) + (MOUNTAIN_AVG_SCALE - MOUNTAIN_SCALE_VARIANCE);
                this.width = this.image.width * this.scale;
                this.height = this.image.height * this.scale;
                this.y = MOUNTAIN_Y_POS; this.speedModifier = 0.06;
            }
            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                }
            }
        }
        class Obstacle {
             constructor() { this.x = canvas.width; this.frame = 0; this.frameTimer = 0; this.passed = false; }
             update(deltaTime) { this.x -= gameState.gameSpeed * this.speedModifier * deltaTime; }
        }
        class Shuriken extends Obstacle {
            constructor() {
                super();
                this.image = images.shuriken;
                this.spriteWidth = 50; this.spriteHeight = 50;
                this.width = 70; this.height = 70;
                this.y = SHURIKEN_FLYING_HEIGHTS[Math.floor(Math.random() * SHURIKEN_FLYING_HEIGHTS.length)];
                this.speedModifier = 1.1; this.hitbox = { offsetX: 15, offsetY: 15, width: 45, height: 40 };
            }
            update(deltaTime) {
                super.update(deltaTime);
                this.frameTimer += deltaTime;
                const stateData = animationStates.shuriken;
                if (this.frameTimer >= stateData.frameDuration) {
                    this.frame = (this.frame + 1) % stateData.frames;
                    this.frameTimer = 0;
                }
            }
            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    const stateData = animationStates.shuriken;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                    if (DEBUG_MODE) {
                        ctx.save();
                        ctx.strokeStyle = 'red';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(this.x + this.hitbox.offsetX, this.y + this.hitbox.offsetY, this.hitbox.width, this.hitbox.height);
                        ctx.restore();
                    }
                }
            }
        }
        class Lantern extends Obstacle {
            constructor() {
                super();
                this.image = images.lantern;
                this.width = 90; this.height = 90;
                this.y = PLAYER_GROUND_LEVEL + PLAYER_DRAW_HEIGHT - this.height - 1;
                this.speedModifier = 1.0;
                this.hitbox = { offsetX: 18, offsetY: 10, width: 55, height: 65 };
            }
             draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                    if (DEBUG_MODE) {
                        ctx.save();
                        ctx.strokeStyle = 'red';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(this.x + this.hitbox.offsetX, this.y + this.hitbox.offsetY, this.hitbox.width, this.hitbox.height);
                        ctx.restore();
                    }
                }
             }
        }
        class Rock extends Obstacle {
            constructor() {
                super();
                this.image = images.rock;
                this.width = 140; this.height = 130;
                this.y = PLAYER_GROUND_LEVEL + PLAYER_DRAW_HEIGHT - this.height + 20;
                this.speedModifier = 1.0;
                this.hitbox = { offsetX: 40, offsetY: 60 , width: 60, height: 45 };
            }
            draw() {
                 if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                    if (DEBUG_MODE) {
                        ctx.save();
                        ctx.strokeStyle = 'red';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(this.x + this.hitbox.offsetX, this.y + this.hitbox.offsetY, this.hitbox.width, this.hitbox.height);
                        ctx.restore();
                    }
                }
            }
        }
        class TeleportGold extends Obstacle {
            constructor() {
                super();
                this.image = images.teleportGold;
                this.spriteWidth = 80; this.spriteHeight = 80;
                this.width = 60; this.height = 60;
                this.y = SHURIKEN_FLYING_HEIGHTS[Math.floor(Math.random() * SHURIKEN_FLYING_HEIGHTS.length)];
                this.speedModifier = 1; this.hitbox = { offsetX: 0, offsetY: 0, width: 60, height: 60 };
            }
            update(deltaTime) {
                super.update(deltaTime);
                this.frameTimer += deltaTime;
                const stateData = animationStates.teleportGold;
                if (this.frameTimer >= stateData.frameDuration) {
                    this.frame = (this.frame + 1) % stateData.frames;
                    this.frameTimer = 0;
                }
            }
            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    const stateData = animationStates.teleportGold;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                }
            }
        }
        class BonusPoints extends Obstacle {
            constructor() {
                super();
                this.image = Math.random() < 0.5 ? images.apple : images.carrot;
                this.width = 80; this.height = 80;
                this.y = SHURIKEN_FLYING_HEIGHTS[Math.floor(Math.random() * SHURIKEN_FLYING_HEIGHTS.length)];
                this.speedModifier = 1;
                this.hitbox = { offsetX: 0, offsetY: 0, width: 80, height: 80 };
            }
            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                }
            }
        }

        // --- Game Logic Handlers ---
        function handleScenery(deltaTime) {
            collections.sceneryArray.forEach(item => item.update(deltaTime));
            collections.sceneryArray = collections.sceneryArray.filter(item => item.x > -item.width);
            if (gameState.gameOver || gameState.isRestarting || gameState.isResetting) return;
            const minMountainSpawnDistance = canvas.width;
            const mountainSpawnChance = 0.005;
            let canSpawnMountain = collections.sceneryArray.length === 0 || collections.sceneryArray[collections.sceneryArray.length - 1].x < canvas.width - minMountainSpawnDistance;
            if (canSpawnMountain && Math.random() < mountainSpawnChance) {
                collections.sceneryArray.push(new Mountain());
            }
        }
        function handleObstacles(deltaTime) {
            collections.obstaclesArray.forEach(obstacle => obstacle.update(deltaTime));
            if (gameState.gameOver || gameState.isRestarting || gameState.isResetting) return;
            const minSpawnDistance = canvas.width / 1.1;
            const spawnChance = 0.015;
            let canSpawn = (collections.obstaclesArray.length === 0 && !gameState.isRestarting) || (collections.obstaclesArray.length > 0 && collections.obstaclesArray[collections.obstaclesArray.length - 1].x < canvas.width - minSpawnDistance);
            if (canSpawn && Math.random() < spawnChance) {
                let currentMilestoneKey = '0';
                if (gameState.score < 3000) currentMilestoneKey = '3000';
                else if (gameState.score < 6000) currentMilestoneKey = '6000';
                else if (gameState.score < 9000) currentMilestoneKey = '9000';
                else if (gameState.score < 12000) currentMilestoneKey = '12000';
                else if (gameState.score < 15000) currentMilestoneKey = '15000';
                else if (gameState.score < 18000) currentMilestoneKey = '18000';
                else if (gameState.score < 21000) currentMilestoneKey = '21000';
                let bonusSpawned = false;
                if (bonusLimits.teleportGold[currentMilestoneKey] && bonusSpawns.teleportGold[currentMilestoneKey] < bonusLimits.teleportGold[currentMilestoneKey] && Math.random() < 0.15) {
                    collections.obstaclesArray.push(new TeleportGold());
                    bonusSpawns.teleportGold[currentMilestoneKey]++;
                    bonusSpawned = true;
                } 
                else if (bonusLimits.bonusPoints[currentMilestoneKey] && bonusSpawns.bonusPoints[currentMilestoneKey] < bonusLimits.bonusPoints[currentMilestoneKey] && Math.random() < 0.25) {
                    collections.obstaclesArray.push(new BonusPoints());
                    bonusSpawns.bonusPoints[currentMilestoneKey]++;
                    bonusSpawned = true;
                }
                if (!bonusSpawned) {
                    const obstacleType = Math.random();
                    if (obstacleType < 0.4) collections.obstaclesArray.push(new Shuriken());
                    else if (Math.random() < 0.5) collections.obstaclesArray.push(new Lantern());
                    else collections.obstaclesArray.push(new Rock());
                }
            }
        }
        function addScore(points, color = {r:0, g:100, b:0}) {
            const oldScore = gameState.score;
            gameState.score += points;

            if (Math.floor(gameState.score / 1000) > Math.floor(oldScore / 1000)) {
                sounds.kabuki.play();
                timers.scoreBounceTimer = 0.5;
            }
            if (gameState.score >= gameState.scoreMilestone * 3000) {
                resetGameForNextLevel();
                return true;
            }
            collections.floatingScores.push(new FloatingScore(points, player.x + player.width / 2 + 30, player.y, color));
            return false;
        }
        function checkCollisionsAndScore() {
            if (gameState.gameOver) return;
            const playerHitbox = player.isCrouching ? player.crouchHitbox : player.hitbox;
            const px = player.x + playerHitbox.offsetX;
            const py = player.y + playerHitbox.offsetY;
            const pw = playerHitbox.width;
            const ph = playerHitbox.height;
            for (let i = collections.obstaclesArray.length - 1; i >= 0; i--) {
                const obstacle = collections.obstaclesArray[i];
                const ox = obstacle.x + obstacle.hitbox.offsetX;
                const oy = obstacle.y + obstacle.hitbox.offsetY;
                const ow = obstacle.hitbox.width;
                const oh = obstacle.hitbox.height;
                if (px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy) {
                    if (obstacle instanceof TeleportGold) {
                        gameState.teleportCharges++;
                        timers.teleportBounceTimer = 1;
                        sounds.secret.currentTime = 0;
                        sounds.secret.play();
                        collections.obstaclesArray.splice(i, 1);
                    } else if (obstacle instanceof BonusPoints) {
                        const points = Math.floor(Math.random() * 151) + 150;
                        const didReset = addScore(points, {r: 0, g: 100, b: 255});
                        sounds.eat.currentTime = 0;
                        sounds.eat.play();
                        collections.obstaclesArray.splice(i, 1);
                        if (didReset) return;
                    } else if (gameState.teleportCharges > 0) {
                        gameState.teleportCharges--;
                        player.isTeleporting = true;
                        sounds.teleport.currentTime = 0;
                        sounds.teleport.play();
                        collections.effectsArray.push(new TeleportEffect(player.x, player.y, player.isJumping));
                        collections.obstaclesArray.splice(i, 1);
                    } else {
                        gameState.gameOver = true;
                        player.state = 'fall';
                        player.frame = 0;
                        sounds.end.play();
                        sounds.fail.play();
                        sounds.track.pause();
                        sounds.track.currentTime = 0;
                        setTimeout(() => { gameState.canRestart = true; }, 2000);
                    }
                }
                if (!obstacle.passed && obstacle.x + obstacle.width < player.x) {
                    obstacle.passed = true;
                    if (!(obstacle instanceof TeleportGold) && !(obstacle instanceof BonusPoints)) {
                        sounds.woosh.currentTime = 0;
                        sounds.woosh.play();
                        const points = 100;
                        const didReset = addScore(points);
                        if (didReset) return;
                    }
                }
            }
        }
        function resetGameForNextLevel() {
            gameState.gameSpeed = 300;
            collections.obstaclesArray = [];
            collections.floatingScores = [];
            sounds.bell.play();
            gameState.scoreMilestone++;
            if (gameState.score >= 21000) {
                gameState.gameWon = true;
                gameState.inversionTarget = 1;
                sounds.track.pause();
                setTimeout(() => { gameState.canRestart = true; }, 2000);
            } else if (gameState.score >= 15000 && gameState.score < 18000) {
                 gameState.inversionTarget = 1;
            } else if (gameState.score >= 9000 && gameState.score < 12000) {
                 gameState.inversionTarget = 1;
            } else if (gameState.score >= 3000 && gameState.score < 6000) {
                 gameState.inversionTarget = 1;
            } else {
                 gameState.inversionTarget = 0;
            }
            if (!player.isJumping) {
                player.state = 'run';
                player.frame = 0;
            }
        }

        function fullGameReset(fromSpacebar = false) {
            gameState.isResetting = false;
            
            if(!fromSpacebar) {
                uiState.menuState = 'loop';
                uiState.menuFrame = 0;
                timers.menuFrameTimer = 0;
                sounds.intro.currentTime = 0;
                sounds.intro.play();
            }

            gameState.gameOver = false; 
            gameState.gameWon = false; 
            gameState.gameSpeed = 300; 
            gameState.score = 0;
            gameState.gameOverFade = 0; 
            timers.uiFadeInTimer = 0;
            collections.obstaclesArray = []; 
            collections.sceneryArray = []; 
            collections.effectsArray = []; 
            collections.floatingScores = [];
            gameState.scoreMilestone = 1; 
            gameState.teleportCharges = 0; 
            gameState.inversionAmount = 0; 
            gameState.inversionTarget = 0;
            timers.scoreBounceTimer = 0; 
            timers.teleportBounceTimer = 0;
            inputState.wantsToCrouch = false;
            bonusSpawns = {
                teleportGold: { '3000': 0, '9000': 0, '15000': 0 },
                bonusPoints: { '3000': 0, '6000': 0, '9000': 0, '12000': 0, '15000': 0, '18000': 0, '21000': 0 }
            };
            player.y = PLAYER_GROUND_LEVEL; player.state = 'run'; player.frame = 0; player.frameTimer = 0;
            player.isJumping = false; player.isCrouching = false; player.isTeleporting = false; player.velocityY = 0;
            
            if (fromSpacebar) {
                startGame();
            } else {
                gameState.gameStarted = false;
            }
        }

        // --- Game/Menu Loops ---
        function updateMenu(deltaTime) {
            timers.menuFrameTimer += deltaTime;
            let stateData;
            if (uiState.menuState === 'intro') stateData = animationStates.menuIntro;
            else if (uiState.menuState === 'loop') stateData = animationStates.menuLoop;
            else if (uiState.menuState === 'outro') stateData = animationStates.menuOutro;

            if (stateData && timers.menuFrameTimer >= stateData.frameDuration) {
                uiState.menuFrame++;
                timers.menuFrameTimer = 0;
                
                if (uiState.menuState === 'intro' && uiState.menuFrame >= stateData.frames) {
                    uiState.showPreMenuBehindIntro = false;
                    if (gameState.isResetting) {
                        fullGameReset();
                    } else {
                        uiState.menuState = 'loop';
                        uiState.menuFrame = 0;
                    }
                } else if (uiState.menuState === 'loop' && uiState.menuFrame >= stateData.frames) {
                    uiState.menuFrame = 0;
                } else if (uiState.menuState === 'outro' && uiState.menuFrame >= stateData.frames) {
                    uiState.menuState = 'inactive';
                }
            }
        }

        function startGame() {
            gameState.gameStarted = true;
            sounds.start.play();
            sounds.roll.play();
            sounds.track.currentTime = 0;
            sounds.track.play();
            collections.effectsArray.push(new RunCloud());
        }
        
        // --- Main Update and Draw Functions ---
        function update(deltaTime) {
            // This needs to update every frame for the portrait mode message
            timers.rotateFrameTimer += deltaTime;
            const rotateData = animationStates.rotate;
            if (rotateData && timers.rotateFrameTimer >= rotateData.frameDuration) {
                uiState.rotateFrame = (uiState.rotateFrame + 1) % rotateData.frames;
                timers.rotateFrameTimer = 0;
            }

            // UI Button animations should always update
            const volBtn = volumeButton;
            volBtn.scale += (volBtn.targetScale - volBtn.scale) * 0.2;
            volBtn.opacity += (volBtn.targetOpacity - volBtn.opacity) * 0.2;
            volBtn.frameTimer += deltaTime;
            const volAnimData = animationStates.volume;
            if (volAnimData && volBtn.frameTimer >= volAnimData.frameDuration) {
                if (uiState.isMuted && volBtn.frame > 0) {
                    volBtn.frame--;
                    volBtn.frameTimer = 0;
                } else if (!uiState.isMuted && volBtn.frame < volAnimData.frames - 1) {
                    volBtn.frame++;
                    volBtn.frameTimer = 0;
                }
            }

            // Scroll button slide animation
            if (uiState.menuState === 'intro' || uiState.menuState === 'loop') {
                scrollButton.y += (scrollButton.targetY - scrollButton.y) * 0.05;
            } else {
                scrollButton.y += (canvas.height + 50 - scrollButton.y) * 0.05;
            }

            if (uiState.menuState === 'loop' && !scrollButton.isAnimating && !uiState.isInfoBoxVisible) {
                const pulse = 1 + Math.sin(timers.lastTime / 500) * 0.05;
                scrollButton.scale = pulse;
            } else {
                scrollButton.scale = 1;
            }

            // Scroll button frame animation
            if (scrollButton.isAnimating) {
                scrollButton.frameTimer += deltaTime;
                const scrollAnimData = animationStates.scroll;
                if (scrollAnimData && scrollButton.frameTimer >= scrollAnimData.frameDuration) {
                    scrollButton.frame += scrollButton.animationDirection;
                    scrollButton.frameTimer = 0;
                    if (scrollButton.frame >= scrollAnimData.frames - 1 || scrollButton.frame <= 0) {
                        scrollButton.frame = Math.max(0, Math.min(scrollAnimData.frames - 1, scrollButton.frame));
                        scrollButton.isAnimating = false;
                    }
                }
            }

            if (uiState.menuState === 'pre-menu' || uiState.showPreMenuBehindIntro) {
                timers.preMenuFrameTimer += deltaTime;
                const preMenuAnimation = isMobile ? animationStates.tap : animationStates.space;
                if (preMenuAnimation && timers.preMenuFrameTimer >= preMenuAnimation.frameDuration) {
                    uiState.preMenuFrame = (uiState.preMenuFrame + 1) % preMenuAnimation.frames;
                    timers.preMenuFrameTimer = 0;
                }
                if (!uiState.showPreMenuBehindIntro) return;
            }

            if (gameState.isRestarting) {
                gameState.restartFadeAmount += 2 * gameState.fadeDirection * deltaTime;
                if (gameState.restartFadeAmount >= 1 && gameState.fadeDirection === 1) {
                    gameState.fadeDirection = -1;
                    fullGameReset(true); 
                }
                if (gameState.restartFadeAmount <= 0 && gameState.fadeDirection === -1) {
                    gameState.isRestarting = false;
                    gameState.fadeDirection = 1;
                }
            }
            
            if (gameState.isResetting || gameState.isRestartButtonAnimating) {
                 updateMenu(deltaTime);
            }

            if ((uiState.menuState === 'intro' || uiState.menuState === 'loop' || uiState.menuState === 'outro') && !gameState.isResetting && !gameState.isRestartButtonAnimating) {
                updateMenu(deltaTime);
            }

            if (!gameState.gameStarted) {
                if (gameState.isRestartButtonAnimating) {
                     //fallthrough to button animation logic
                } else {
                    return;
                }
            }
            
            if (gameState.gameStarted) {
                handleScenery(deltaTime);
                handleObstacles(deltaTime);
                checkCollisionsAndScore();
                
                for (let i = collections.floatingScores.length - 1; i >= 0; i--) {
                    collections.floatingScores[i].update(deltaTime);
                    if (collections.floatingScores[i].opacity <= 0) {
                        collections.floatingScores.splice(i, 1);
                    }
                }

                if (gameState.gameOver || gameState.gameWon) {
                    if (gameState.gameSpeed > 0) gameState.gameSpeed -= 800 * deltaTime;
                    else gameState.gameSpeed = 0;
                    collections.effectsArray.forEach(effect => { if(effect instanceof RunCloud) effect.startFading() });
                    if (gameState.gameOver && gameState.gameOverFade < 1) gameState.gameOverFade += 2 * deltaTime;
                } else {
                    if(!gameState.isRestarting) gameState.gameSpeed += speedIncreaseRate * 60 * deltaTime;
                }
                
                if (inputState.isHoldingTouch && gameState.gameStarted && !player.isJumping) {
                    const holdDuration = Date.now() - timers.touchStartTime;
                    if (holdDuration > 200) {
                        handleCrouchStart();
                    }
                }

                if (timers.scoreBounceTimer > 0) timers.scoreBounceTimer -= deltaTime;
                if (timers.teleportBounceTimer > 0) timers.teleportBounceTimer -= deltaTime;
                
                const transitionSpeed = 1 / 4;
                if (gameState.inversionAmount < gameState.inversionTarget) {
                    gameState.inversionAmount = Math.min(gameState.inversionTarget, gameState.inversionAmount + transitionSpeed * deltaTime);
                } else if (gameState.inversionAmount > gameState.inversionTarget) {
                    gameState.inversionAmount = Math.max(gameState.inversionTarget, gameState.inversionAmount - transitionSpeed * deltaTime);
                }
                gameState.groundX -= gameState.gameSpeed * deltaTime;
                gameState.bg1X -= gameState.gameSpeed * 0.1 * deltaTime;
                gameState.bg2X -= gameState.gameSpeed * 0.03 * deltaTime;
                gameState.grassX -= gameState.gameSpeed * GRASS_SPEED_MODIFIER * deltaTime;
                
                const bg1_scaledWidth = images.background1 ? images.background1.width * BG1_SCALE : 0;
                const bg2_scaledWidth = images.background2 ? images.background2.width * BG2_SCALE : 0;
                const grass_scaledWidth = images.grass ? images.grass.width * GRASS_SCALE : 0;

                if (images.ground && gameState.groundX <= -images.ground.width) gameState.groundX += images.ground.width;
                if (bg1_scaledWidth > 0 && gameState.bg1X <= -bg1_scaledWidth) gameState.bg1X += bg1_scaledWidth;
                if (bg2_scaledWidth > 0 && gameState.bg2X <= -bg2_scaledWidth) gameState.bg2X += bg2_scaledWidth;
                if (grass_scaledWidth > 0 && gameState.grassX <= -grass_scaledWidth) gameState.grassX += grass_scaledWidth;
                
                if (player.isJumping) {
                    player.velocityY += GRAVITY * deltaTime;
                    player.y += player.velocityY * deltaTime;
                }
                if (player.y > PLAYER_GROUND_LEVEL) {
                    player.y = PLAYER_GROUND_LEVEL;
                    if(player.isJumping) {
                        collections.effectsArray.forEach(effect => { if(effect instanceof RunCloud) effect.activate() });
                    }
                    player.isJumping = false;
                    player.velocityY = 0;
                    if (inputState.wantsToCrouch) {
                        handleCrouchStart();
                    } else if (!player.isCrouching && !gameState.gameOver) { 
                        player.state = 'run'; 
                    }
                }
                player.frameTimer += deltaTime;
                const stateData = animationStates[player.state];
                if (stateData) {
                    let dynamicFrameDuration = stateData.frameDuration;
                    if (player.state === 'run' || player.state === 'crouch') {
                        dynamicFrameDuration = Math.max(0.02, stateData.frameDuration - (gameState.gameSpeed / 10000));
                    }
                    if (player.frameTimer >= dynamicFrameDuration) {
                        if (player.state === 'fall') {
                            if (player.frame < stateData.frames - 1) player.frame++;
                        } else {
                            player.frame = (player.frame + 1) % stateData.frames;
                        }
                        player.frameTimer = 0;
                    }
                }
                collections.effectsArray.forEach(effect => effect.update(deltaTime));
                collections.effectsArray = collections.effectsArray.filter(effect => !effect.markedForDeletion);
            }

            if (gameState.canRestart || gameState.isRestartButtonAnimating) {
                restartButton.frameTimer += deltaTime;
                if ((restartButton.isHovered && !isMobile) || gameState.isRestartButtonAnimating) {
                    const stateData = animationStates.button;
                    if (stateData && restartButton.frameTimer >= stateData.frameDuration) {
                        restartButton.frameTimer = 0;
                        if (gameState.isRestartButtonAnimating) {
                            restartButton.frame++;
                            if (restartButton.frame >= stateData.frames) {
                                gameState.isRestartButtonAnimating = false;
                                restartButton.frame = 0;
                                gameState.isResetting = true;
                                uiState.menuState = 'intro';
                                uiState.menuFrame = 0;
                                timers.menuFrameTimer = 0;
                                sounds.gateClose.play();
                                if(sounds.gecko) sounds.gecko.pause();
                            }
                        } else { 
                            restartButton.frame = (restartButton.frame + 1) % stateData.frames;
                        }
                    }
                } else {
                    restartButton.frame = 0;
                }
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (uiState.menuState === 'pre-menu') {
                drawPreMenu();
            } else if (gameState.isResetting || gameState.isRestartButtonAnimating) {
                drawGameWorld(); 
                drawEndScreens(); 
                if (!gameState.isRestartButtonAnimating) {
                    drawMenu(); 
                }
            } else if (uiState.menuState === 'intro' || uiState.menuState === 'loop') {
                if (uiState.showPreMenuBehindIntro) {
                    drawPreMenu();
                }
                drawMenu();
            } else { 
                drawGameWorld();
                drawUI();
                drawEndScreens();
                if (uiState.menuState === 'outro') {
                    drawMenu(); 
                }
            }

            if (uiState.menuState === 'intro' || uiState.menuState === 'loop' || uiState.menuState === 'outro') {
                drawScrollButton();
            }

            if (uiState.menuState === 'loop') {
                 drawInfoBox();
            }


            if ((gameState.canRestart && (gameState.gameOver || gameState.gameWon)) || gameState.isRestartButtonAnimating) {
                drawRestartButton();
            }
            drawVolumeButton();

            if (gameState.isRestarting) {
                ctx.fillStyle = `rgba(255, 255, 255, ${gameState.restartFadeAmount})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // --- Drawing Sub-functions ---
        function drawGameWorld() {
             ctx.save();
             ctx.filter = `invert(${gameState.inversionAmount * 100}%)`;
             ctx.fillStyle = '#f0f0f0';
             ctx.fillRect(0, 0, canvas.width, canvas.height);
             if (images.background2 && images.background2.complete && images.background2.naturalWidth > 0) {
                 const scaledWidth = images.background2.width * BG2_SCALE;
                 const scaledHeight = (images.background2.naturalHeight / images.background2.naturalWidth) * scaledWidth;
                 ctx.drawImage(images.background2, Math.floor(gameState.bg2X), BG2_Y_POS, scaledWidth, scaledHeight);
                 ctx.drawImage(images.background2, Math.floor(gameState.bg2X + scaledWidth) - 1, BG2_Y_POS, scaledWidth, scaledHeight);
                 ctx.drawImage(images.background2, Math.floor(gameState.bg2X + scaledWidth * 2) - 2, BG2_Y_POS, scaledWidth, scaledHeight);
             }
             collections.sceneryArray.forEach(item => item.draw());
             if (images.background1 && images.background1.complete && images.background1.naturalWidth > 0) {
                 const scaledWidth = images.background1.width * BG1_SCALE;
                 const scaledHeight = (images.background1.naturalHeight / images.background1.naturalWidth) * scaledWidth;
                 ctx.drawImage(images.background1, Math.floor(gameState.bg1X), BG1_Y_POS, scaledWidth, scaledHeight);
                 ctx.drawImage(images.background1, Math.floor(gameState.bg1X + scaledWidth) - 1, BG1_Y_POS, scaledWidth, scaledHeight);
                 ctx.drawImage(images.background1, Math.floor(gameState.bg1X + scaledWidth * 2) - 2, BG1_Y_POS, scaledWidth, scaledHeight);
             }
             if (images.ground && images.ground.complete && images.ground.naturalWidth > 0) {
                 const groundY = canvas.height - GROUND_HEIGHT_PHYSICS + VISUAL_GROUND_Y_OFFSET;
                 ctx.drawImage(images.ground, Math.floor(gameState.groundX), groundY, images.ground.width, VISUAL_GROUND_HEIGHT);
                 ctx.drawImage(images.ground, Math.floor(gameState.groundX + images.ground.width) -1, groundY, images.ground.width, VISUAL_GROUND_HEIGHT);
                 ctx.drawImage(images.ground, Math.floor(gameState.groundX + images.ground.width * 2) -2, groundY, images.ground.width, VISUAL_GROUND_HEIGHT);
             }
             collections.obstaclesArray.forEach(obstacle => obstacle.draw());
             collections.effectsArray.forEach(effect => effect.draw());
             if (!player.isTeleporting) {
                 const playerStateData = animationStates[player.state];
                 if (images[player.state] && images[player.state].complete && images[player.state].naturalWidth > 0) {
                     const columns = playerStateData.columns;
                     const frameX = player.frame % columns;
                     const frameY = Math.floor(player.frame / columns);
                     const sourceX = frameX * PLAYER_SPRITE_WIDTH;
                     const sourceY = frameY * PLAYER_SPRITE_HEIGHT;
                     ctx.drawImage(images[player.state], sourceX, sourceY, PLAYER_SPRITE_WIDTH, PLAYER_SPRITE_HEIGHT, player.x, player.y, player.width, player.height);
                     if (DEBUG_MODE) {
                         ctx.save();
                         ctx.strokeStyle = 'blue';
                         ctx.lineWidth = 1;
                         let currentHitbox = player.isCrouching ? player.crouchHitbox : player.hitbox;
                         ctx.strokeRect(player.x + currentHitbox.offsetX, player.y + currentHitbox.offsetY, currentHitbox.width, currentHitbox.height);
                         ctx.restore();
                     }
                 }
             }
             if (images.grass && images.grass.complete && images.grass.naturalWidth > 0) {
                 const scaledWidth = images.grass.width * GRASS_SCALE;
                 const scaledHeight = images.grass.height * GRASS_SCALE;
                 ctx.drawImage(images.grass, Math.floor(gameState.grassX), GRASS_Y_POS, scaledWidth, scaledHeight);
                 ctx.drawImage(images.grass, Math.floor(gameState.grassX + scaledWidth) - 1, GRASS_Y_POS, scaledWidth, scaledHeight);
                 ctx.drawImage(images.grass, Math.floor(gameState.grassX + scaledWidth * 2) - 2, GRASS_Y_POS, scaledWidth, scaledHeight);
             }
             
             collections.floatingScores.forEach(fs => fs.draw());
             
             ctx.restore();
        }

        function drawUI() {
            ctx.save();
            if (gameState.gameStarted) timers.uiFadeInTimer = Math.min(1, timers.uiFadeInTimer + (1/60));
            ctx.globalAlpha = timers.uiFadeInTimer;
            ctx.textAlign = 'right';
            const scoreNumberText = gameState.score.toString();
            
            let scoreFontSize = 30;
            let scoreLabelScale = 1.0;
            if (timers.scoreBounceTimer > 0) {
                const bounceScale = 1 + Math.sin(timers.scoreBounceTimer * (1/0.5) * Math.PI) * 0.5;
                scoreFontSize *= bounceScale;
                ctx.fillStyle = 'red';
            } else {
                ctx.fillStyle = 'black';
            }
            
            ctx.font = `${scoreFontSize}px Amanojaku`;
            const scoreNumberWidth = ctx.measureText(scoreNumberText).width;
            ctx.fillText(scoreNumberText, canvas.width - 20, 40);
            
            ctx.fillStyle = 'black';
            ctx.font = `bold ${24 * scoreLabelScale}px Amanojaku`;
            
            const scoreLabel = 'SCORE: ';
            const scoreLabelWidth = ctx.measureText(scoreLabel).width;
            const scoreX = canvas.width - 20 - scoreNumberWidth;
            
            ctx.fillText(scoreLabel, scoreX, 40);

            ctx.textAlign = 'left';
            if (gameState.teleportCharges > 0 && images.teleportLogo && images.teleportLogo.complete && images.teleportLogo.naturalWidth > 0) {
                ctx.drawImage(images.teleportLogo, 20, 15, 40, 40);

                let teleportFontSize = 30;
                if(timers.teleportBounceTimer > 0) {
                    const bounceScale = 1 + Math.sin(timers.teleportBounceTimer * Math.PI) * 0.5;
                    teleportFontSize *= bounceScale;
                    ctx.fillStyle = `hsl(${ (1 - timers.teleportBounceTimer) * 360 }, 100%, 50%)`;
                } else {
                    ctx.fillStyle = 'black';
                }

                ctx.font = `${teleportFontSize}px Amanojaku`;
                ctx.fillText('x', 65, 45);
                const x_width = ctx.measureText('x').width;

                ctx.font = `bold ${teleportFontSize}px "Segoe UI"`;
                ctx.fillText(gameState.teleportCharges, 65 + x_width, 45);
            }
            ctx.restore();
            ctx.textAlign = 'center';
        }

        function drawEndScreens() {
            if (gameState.gameOver) {
                ctx.fillStyle = `rgba(0, 0, 0, ${0.7 * gameState.gameOverFade})`;
                ctx.font = '70px Amanojaku';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 20);
                if (gameState.canRestart) {
                    ctx.fillStyle = `rgba(0, 0, 0, ${1 * gameState.gameOverFade})`;
                    ctx.font = 'bold 20px "Segoe UI"';
                    ctx.fillText(isMobile ? 'Tap to restart' : 'press SPACE to restart', canvas.width / 2, canvas.height / 2 + 20);
                }
            }
            if (gameState.gameWon) {
                ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'black';
                ctx.font = '50px Amanojaku';
                ctx.fillText('YOU WIN', canvas.width / 2, canvas.height / 2 - 20);
                if (gameState.canRestart) {
                    ctx.font = 'bold 20px "Segoe UI"';
                    ctx.fillText(isMobile ? 'Tap to restart' : 'press SPACE to restart', canvas.width / 2, canvas.height / 2 + 20);
                }
            }
        }
        
        function drawRestartButton() {
            if (images.button && images.button.complete && images.button.naturalWidth > 0) {
                const stateData = animationStates.button;
                const columns = stateData.columns;
                const frameX = restartButton.frame % columns;
                const frameY = Math.floor(restartButton.frame / columns);
                const sourceX = frameX * stateData.spriteWidth;
                const sourceY = frameY * stateData.spriteHeight;
                
                let drawWidth = restartButton.width;
                let drawHeight = restartButton.height;
                let drawX = restartButton.x;
                let drawY = restartButton.y;

                if (restartButton.isPressed) {
                    const scale = 0.9;
                    drawWidth *= scale;
                    drawHeight *= scale;
                    drawX += (restartButton.width - drawWidth) / 2;
                    drawY += (restartButton.height - drawHeight) / 2;
                }

                ctx.drawImage(images.button, sourceX, sourceY, stateData.spriteWidth, stateData.spriteHeight, drawX, drawY, drawWidth, drawHeight);
            }
        }

        function drawPreMenu() {
            if ((isMobile && images.tap && images.tap.complete && images.tap.naturalWidth > 0) || (!isMobile && images.space && images.space.complete && images.space.naturalWidth > 0)) {
                const preMenuImage = isMobile ? images.tap : images.space;
                const stateData = isMobile ? animationStates.tap : animationStates.space;
                const columns = stateData.columns;
                const frameX = uiState.preMenuFrame % columns;
                const frameY = Math.floor(uiState.preMenuFrame / columns);
                const sourceX = frameX * stateData.spriteWidth;
                const sourceY = frameY * stateData.spriteHeight;
                ctx.drawImage(preMenuImage, sourceX, sourceY, stateData.spriteWidth, stateData.spriteHeight, 0, 0, canvas.width, canvas.height);
            }
        }

        function drawMenu() {
            let currentImage;
            let stateData;
            if (uiState.menuState === 'intro') {
                currentImage = images.menuIntro;
                stateData = animationStates.menuIntro;
            } else if (uiState.menuState === 'loop') {
                currentImage = images.menuLoop;
                stateData = animationStates.menuLoop;
            } else if (uiState.menuState === 'outro') {
                currentImage = images.menuOutro;
                stateData = animationStates.menuOutro;
            }

            if (currentImage && currentImage.complete && currentImage.naturalWidth > 0) {
                const columns = stateData.columns;
                const frameX = uiState.menuFrame % columns;
                const frameY = Math.floor(uiState.menuFrame / columns);
                const sourceX = frameX * stateData.spriteWidth;
                const sourceY = frameY * stateData.spriteHeight;
                ctx.drawImage(currentImage, sourceX, sourceY, stateData.spriteWidth, stateData.spriteHeight, 0, 0, canvas.width, canvas.height);
            }
        }

        function drawScrollButton() {
            if (images.scroll && images.scroll.complete && images.scroll.naturalWidth > 0) {
                const btn = scrollButton;
                const stateData = animationStates.scroll;
                const columns = stateData.columns;
                const frameX = btn.frame % columns;
                const frameY = Math.floor(btn.frame / columns);
                const sourceX = frameX * stateData.spriteWidth;
                const sourceY = frameY * stateData.spriteHeight;

                const w = btn.width * btn.scale;
                const h = btn.height * btn.scale;
                const x = btn.x - (w - btn.width) / 2;
                const y = btn.y - (h - btn.height) / 2;

                ctx.drawImage(images.scroll, sourceX, sourceY, stateData.spriteWidth, stateData.spriteHeight, x, y, w, h);
            }
        }

        function drawInfoBox() {
            if (uiState.isInfoBoxVisible) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                const boxWidth = canvas.width * 0.8;
                const boxHeight = canvas.height * 0.8;
                const boxX = (canvas.width - boxWidth) / 2;
                const boxY = (canvas.height - boxHeight) / 2;
                ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                
                ctx.fillStyle = 'white';
                ctx.font = '20px "Segoe UI"';
                ctx.textAlign = 'center';
                ctx.fillText('Info box placeholder.', canvas.width / 2, canvas.height / 2);
            }
        }
        
        function drawRotateCanvas() {
            if (images.rotate && images.rotate.complete && images.rotate.naturalWidth > 0) {
                const stateData = animationStates.rotate;
                const columns = stateData.columns;
                const frameX = uiState.rotateFrame % columns;
                const frameY = Math.floor(uiState.rotateFrame / columns);
                const sourceX = frameX * stateData.spriteWidth;
                const sourceY = frameY * stateData.spriteHeight;
                rotateCtx.clearRect(0,0, rotateCanvas.width, rotateCanvas.height);
                rotateCtx.drawImage(images.rotate, sourceX, sourceY, stateData.spriteWidth, stateData.spriteHeight, 0, 0, rotateCanvas.width, rotateCanvas.height);
            }
        }

        function drawVolumeButton() {
            if (images.volume && images.volume.complete && images.volume.naturalWidth > 0) {
                ctx.save();
                ctx.globalAlpha = volumeButton.opacity;
                const stateData = animationStates.volume;
                const columns = stateData.columns;
                const frameX = volumeButton.frame % columns;
                const frameY = Math.floor(volumeButton.frame / columns);
                const sourceX = frameX * stateData.spriteWidth;
                const sourceY = frameY * stateData.spriteHeight;

                const w = volumeButton.width * volumeButton.scale;
                const h = volumeButton.height * volumeButton.scale;
                const x = volumeButton.x - (w - volumeButton.width) / 2;
                const y = volumeButton.y - (h - volumeButton.height) / 2;

                ctx.drawImage(images.volume, sourceX, sourceY, stateData.spriteWidth, stateData.spriteHeight, x, y, w, h);
                ctx.restore();
            }
        }

        function repositionUIElements() {
            restartButton.x = canvas.width - 130;
            restartButton.y = canvas.height - 130;

            volumeButton.x = canvas.width / 2 - 25;
            volumeButton.y = canvas.height - 70;

            scrollButton.x = canvas.width - 130;
            scrollButton.targetY = canvas.height - 130;

            if (uiState.menuState === 'pre-menu') {
                scrollButton.y = canvas.height + 50;
            }
        }

        // --- Game Initialization ---
        function mainLoop(currentTime) {
            if (!timers.lastTime) timers.lastTime = currentTime;
            const deltaTime = (currentTime - timers.lastTime) / 1000;
            timers.lastTime = currentTime;

            update(deltaTime);
            draw();
            drawRotateCanvas();
            
            requestAnimationFrame(mainLoop);
        }
        
        function initialDraw() {
            if (assetsLoaded < totalAssets) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'black';
                ctx.font = '20px "Segoe UI"';
                ctx.textAlign = 'center';
                ctx.fillText(`Loading... ${Math.round((assetsLoaded / totalAssets) * 100)}%`, canvas.width / 2, canvas.height / 2);
                requestAnimationFrame(initialDraw);
                return;
            }
            
            repositionUIElements();
            window.addEventListener('resize', repositionUIElements);

            timers.lastTime = performance.now();
            mainLoop(timers.lastTime);
        }

        preloadAssets();
        initialDraw();

        // This prevents the default right-click context menu from appearing.
        // It's a simple deterrent but can be easily bypassed by users who know how to open developer tools directly.
        document.addEventListener('contextmenu', event => event.preventDefault());

    </script>
</body>
</html>

