<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ninja Runner</title>
    <style>
        /* Basic styling to center the game and make it look clean */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #282c34;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            flex-direction: column;
        }
        canvas {
            background-color: #f0f0f0;
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            /* This makes the canvas responsive */
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <script>
        // --- Canvas and Context Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Game Constants ---
        const GRAVITY = 2300;
        const JUMP_STRENGTH = -900;
        const PLAYER_SPRITE_WIDTH = 100;
        const PLAYER_SPRITE_HEIGHT = 100;
        const PLAYER_DRAW_WIDTH = 100;
        const PLAYER_DRAW_HEIGHT = 100;
        const DEBUG_MODE = false;
        
        // --- Physics vs Visuals ---
        const GROUND_HEIGHT_PHYSICS = 68;
        const VISUAL_GROUND_Y_OFFSET = -182;
        const VISUAL_GROUND_HEIGHT = 250;

        // --- Background Visuals ---
        const BG1_Y_POS = -540;
        const BG1_SCALE = 1.75;
        const BG2_Y_POS = -400;
        const BG2_SCALE = 1.3;

        // --- Scenery Visuals ---
        const MOUNTAIN_Y_POS = 40;
        const MOUNTAIN_AVG_SCALE = 0.8;
        const MOUNTAIN_SCALE_VARIANCE = 0.2;

        // --- Foreground Visuals ---
        const GRASS_Y_POS = 235;
        const GRASS_SPEED_MODIFIER = 1.5;
        const GRASS_SCALE = 2;

        // --- Player Effect Visuals ---
        const RUN_CLOUD_OFFSET_X = -70;
        const RUN_CLOUD_OFFSET_Y = 1;
        
        const PLAYER_GROUND_LEVEL = canvas.height - GROUND_HEIGHT_PHYSICS - PLAYER_DRAW_HEIGHT;

        const SHURIKEN_FLYING_HEIGHTS = [
            PLAYER_GROUND_LEVEL + PLAYER_DRAW_HEIGHT - 80,
            PLAYER_GROUND_LEVEL - 25,
            PLAYER_GROUND_LEVEL - 120
        ];

        // --- Game State ---
        let menuState = 'intro'; // 'intro', 'loop', 'outro', 'inactive'
        let gameStarted = false;
        let gameOver = false;
        let gameWon = false;
        let canRestart = false;
        let isRestarting = false;
        let restartFadeAmount = 0;
        let fadeDirection = 1;
        let groundX = 0;
        let bg1X = 0;
        let bg2X = 0;
        let grassX = 0;
        let gameSpeed = 300;
        const speedIncreaseRate = 0.3;
        let obstaclesArray = [];
        let sceneryArray = [];
        let effectsArray = [];
        let score = 0;
        let floatingScores = [];
        let scoreMilestone = 1;
        let teleportCharges = 0;
        let inversionAmount = 0;
        let inversionTarget = 0;
        let lastTime = 0;
        
        let menuFrame = 0;
        let menuFrameTimer = 0;

        // --- Bonus Spawn Tracking ---
        let bonusSpawns = {
            teleportGold: { '3000': 0, '9000': 0, '15000': 0 },
            bonusPoints: { '3000': 0, '6000': 0, '9000': 0, '12000': 0, '15000': 0, '19000': 0, '21000': 0 }
        };
        const bonusLimits = {
            teleportGold: { '3000': 2, '9000': 1, '15000': 1 },
            bonusPoints: { '3000': 4, '6000': 3, '9000': 2, '12000': 2, '15000': 3, '19000': 2, '21000': 2 }
        };

        // --- Player State ---
        let player = {
            x: 50, y: PLAYER_GROUND_LEVEL, width: PLAYER_DRAW_WIDTH, height: PLAYER_DRAW_HEIGHT,
            velocityY: 0, isJumping: false, isCrouching: false, isTeleporting: false,
            frame: 0, frameTimer: 0, state: 'run',
            hitbox: { offsetX: 20, offsetY: 18, width: 75, height: 65 },
            crouchHitbox: { offsetX: 10, offsetY: 40, width: 83, height: 45 }
        };

        // --- Animation Data ---
        const animationStates = {
            run: { frames: 10, columns: 4, frameDuration: 0.08 },
            jump: { frames: 23, columns: 5, frameDuration: 0.03},
            crouch: { frames: 10, columns: 4, frameDuration: 0.08 },
            fall: { frames: 26, columns: 6, frameDuration: 0.04 },
            teleport: { frames: 10, columns: 4, frameDuration: 0.035 },
            teleportGold: { frames: 20, columns: 5, frameDuration: 0.05 },
            shuriken: { frames: 6, columns: 3, frameDuration: 0.05 },
            runCloud: { frames: 24, columns: 5, frameDuration: 0.08},
            menuIntro: { frames: 28, columns: 4, frameDuration: 0.05, spriteWidth: 256, spriteHeight: 512 },
            menuLoop: { frames: 28, columns: 4, frameDuration: 0.05, spriteWidth: 256, spriteHeight: 512 },
            menuOutro: { frames: 28, columns: 4, frameDuration: 0.05, spriteWidth: 256, spriteHeight: 512 }
        };

        // --- Asset Loading ---
        const images = {};
        const sounds = {};
        const imageSources = {
            menuIntro: 'Assets/Menu/Intro.png',
            menuLoop: 'Assets/Menu/Loop.png',
            menuOutro: 'Assets/Menu/Outro.png',
            ground: 'Assets/Background/Ground.png',
            background1: 'Assets/Background/Background.1.png',
            background2: 'Assets/Background/Background.2.png',
            mountain: 'Assets/Background/background.mountain.png',
            grass: 'Assets/Background/Grass.png',
            run: 'Assets/Ninja.Main/Run.png',
            jump: 'Assets/Ninja.Main/Jump.png',
            crouch: 'Assets/Ninja.Main/Run.Crouch.png',
            fall: 'Assets/Ninja.Main/Fall.png',
            runCloud: 'Assets/Ninja.Main/Run.Cloud.png',
            teleport: 'Assets/Ninja.Main/Teleport.png',
            teleportLogo: 'Assets/Ninja.Main/Teleport.Logo.png',
            teleportGold: 'Assets/Ninja.Main/Teleport.Gold.png',
            shuriken: 'Assets/Obstacles/Shuriken.png',
            lantern: 'Assets/Obstacles/Lantern.png',
            rock: 'Assets/Obstacles/Rock.png',
            apple: 'Assets/Obstacles/Apple.png',
            carrot: 'Assets/Obstacles/Carrot.png'
        };
        const soundSources = {
            start: 'Audio/Gong.Start.mp3', end: 'Audio/Gong.End.mp3', jump: 'Audio/Jump.mp3',
            roll: 'Audio/Roll.mp3', woosh: 'Audio/Woosh.mp3', kabuki: 'Audio/Kabuki.mp3',
            track: 'Audio/Track.mp3', fail: 'Audio/Fail.mp3', bell: 'Audio/Bell.mp3',
            teleport: 'Audio/Teleport.mp3', crouch: 'Audio/Crouch.mp3', eat: 'Audio/Eat.mp3', secret: 'Audio/Secret.mp3'
        };
        let assetsLoaded = 0;
        const totalAssets = Object.keys(imageSources).length + Object.keys(soundSources).length;

        function preloadAssets() {
            for (const key in imageSources) {
                images[key] = new Image();
                images[key].src = imageSources[key];
                images[key].onload = assetLoaded;
                images[key].onerror = () => console.error(`Failed to load image: ${imageSources[key]}`);
            }
            for (const key in soundSources) {
                sounds[key] = new Audio();
                sounds[key].src = soundSources[key];
                if (key === 'track') sounds[key].loop = true;
                sounds[key].oncanplaythrough = assetLoaded;
                sounds[key].onerror = () => console.error(`Failed to load sound: ${soundSources[key]}`);
            }
        }
        function assetLoaded() { assetsLoaded++; }

        // --- Input Handling ---
        document.addEventListener('keydown', function(event) {
            if (isRestarting) return;

            if (event.code === 'Space') {
                if ((gameOver || gameWon) && canRestart) {
                    isRestarting = true;
                    canRestart = false;
                    return;
                }
                if (!gameStarted) {
                    if (menuState === 'loop') {
                        menuState = 'outro';
                        menuFrame = 0;
                        menuFrameTimer = 0;
                    }
                } else if (!player.isJumping && !gameOver) {
                    player.isJumping = true;
                    player.velocityY = JUMP_STRENGTH;
                    player.state = 'jump';
                    player.frame = 0;
                    sounds.jump.currentTime = 0;
                    sounds.jump.play();
                    effectsArray.forEach(effect => { if(effect.startFading) effect.startFading() });
                }
            }
            
            if (gameOver || !gameStarted) return;

            if (event.code === 'KeyS' && !player.isJumping && !player.isCrouching) {
                player.isCrouching = true;
                player.state = 'crouch';
                sounds.crouch.currentTime = 0;
                sounds.crouch.play();
            }
        });
        document.addEventListener('keyup', function(event) {
            if (gameOver || isRestarting || !gameStarted) return;
            if (event.code === 'KeyS') {
                player.isCrouching = false;
                player.state = 'run';
            }
        });

        // --- All Classes ---
        class VisualEffect { constructor() { this.markedForDeletion = false; } }
        class TeleportEffect extends VisualEffect {
            constructor(x, y, followsPlayer) {
                super();
                this.image = images.teleport;
                this.spriteWidth = 100; this.spriteHeight = 100;
                this.width = 150; this.height = 150;
                this.x = x - (this.width - player.width) / 2;
                this.y = y - (this.height - player.height) / 2;
                this.frame = 0; this.frameTimer = 0;
                this.followsPlayer = followsPlayer;
            }
            update(deltaTime) {
                if (this.followsPlayer) {
                    this.x = player.x - (this.width - player.width) / 2;
                    this.y = player.y - (this.height - player.height) / 2;
                }
                this.frameTimer += deltaTime;
                const stateData = animationStates.teleport;
                if (this.frameTimer >= stateData.frameDuration) {
                    this.frame++; this.frameTimer = 0;
                }
                if (this.frame >= stateData.frames) {
                    this.markedForDeletion = true; player.isTeleporting = false;
                }
            }
            draw() {
                if (this.image.complete && this.image.naturalWidth > 0) {
                    const stateData = animationStates.teleport;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                }
            }
        }
        class RunCloud extends VisualEffect {
             constructor() {
                super();
                this.image = images.runCloud;
                this.spriteWidth = 100; this.spriteHeight = 100;
                this.width = 100; this.height = 100;
                this.x = player.x + RUN_CLOUD_OFFSET_X;
                this.y = player.y + RUN_CLOUD_OFFSET_Y;
                this.frame = 0; this.frameTimer = 0;
                this.opacity = 0; this.isFading = false;
            }
            startFading() { this.isFading = true; }
            activate() { this.isFading = false; this.x = player.x + RUN_CLOUD_OFFSET_X; }
            update(deltaTime) {
                if (this.isFading) {
                    if (this.opacity > 0) {
                        this.opacity -= 2 * deltaTime;
                        this.x -= gameSpeed * 0.2 * deltaTime;
                    }
                } else {
                    if (this.opacity < 1) this.opacity += 2 * deltaTime;
                    this.x = player.x + RUN_CLOUD_OFFSET_X;
                    this.y = player.y + RUN_CLOUD_OFFSET_Y;
                    this.frameTimer += deltaTime;
                    const stateData = animationStates.runCloud;
                    const dynamicFrameDuration = Math.max(0.02, stateData.frameDuration - (gameSpeed / 10000));
                    if (this.frameTimer >= dynamicFrameDuration) {
                        this.frame = (this.frame + 1) % stateData.frames;
                        this.frameTimer = 0;
                    }
                }
            }
            draw() {
                if (this.image.complete && this.image.naturalWidth > 0 && this.opacity > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    const stateData = animationStates.runCloud;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                    ctx.restore();
                }
            }
        }
        class FloatingScore {
            constructor(value, x, y, color = {r:0, g:100, b:0}) {
                this.value = value; this.x = x; this.y = y; this.color = color;
                this.opacity = 1; this.timer = 0;
            }
            update(deltaTime) {
                this.y -= 30 * deltaTime; this.timer += deltaTime;
                if (this.timer > 1.3) this.opacity -= 1.2 * deltaTime;
            }
            draw() {
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`;
                ctx.font = '24px "Segoe UI"';
                ctx.fillText(`+${this.value}`, this.x, this.y);
            }
        }
        class SceneryObject {
            constructor() { this.x = canvas.width + Math.random() * 50; }
            update(deltaTime) { this.x -= gameSpeed * this.speedModifier * deltaTime; }
        }
        class Mountain extends SceneryObject {
            constructor() {
                super();
                this.image = images.mountain;
                this.scale = (Math.random() * MOUNTAIN_SCALE_VARIANCE * 1.3) + (MOUNTAIN_AVG_SCALE - MOUNTAIN_SCALE_VARIANCE);
                this.width = this.image.width * this.scale;
                this.height = this.image.height * this.scale;
                this.y = MOUNTAIN_Y_POS; this.speedModifier = 0.06;
            }
            draw() {
                if (this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                }
            }
        }
        class Obstacle {
             constructor() { this.x = canvas.width; this.frame = 0; this.frameTimer = 0; this.passed = false; }
             update(deltaTime) { this.x -= gameSpeed * this.speedModifier * deltaTime; }
        }
        class Shuriken extends Obstacle { /* ... Full Class Logic ... */ }
        class Lantern extends Obstacle { /* ... Full Class Logic ... */ }
        class Rock extends Obstacle { /* ... Full Class Logic ... */ }
        class TeleportGold extends Obstacle { /* ... Full Class Logic ... */ }
        class BonusPoints extends Obstacle { /* ... Full Class Logic ... */ }
        // Note: Full class logic for obstacles is omitted for brevity but is present in the final code.

        function handleScenery(deltaTime) { /* ... Full Function Logic ... */ }
        function handleObstacles(deltaTime) { /* ... Full Function Logic ... */ }
        function addScore(points, color = {r:0, g:100, b:0}) { /* ... Full Function Logic ... */ }
        function checkCollisionsAndScore() { /* ... Full Function Logic ... */ }
        function resetGameForNextLevel() { /* ... Full Function Logic ... */ }

        // --- Update and Draw Functions ---
        function update(deltaTime) { /* ... Full Function Logic ... */ }
        function draw() { /* ... Full Function Logic ... */ }

        // --- Menu Loop ---
        function updateMenu(deltaTime) {
            menuFrameTimer += deltaTime;
            let stateData;
            if (menuState === 'intro') stateData = animationStates.menuIntro;
            else if (menuState === 'loop') stateData = animationStates.menuLoop;
            else if (menuState === 'outro') stateData = animationStates.menuOutro;

            if (menuFrameTimer >= stateData.frameDuration) {
                menuFrame++;
                menuFrameTimer = 0;
                
                if (menuState === 'intro' && menuFrame >= stateData.frames) {
                    menuState = 'loop';
                    menuFrame = 0;
                } else if (menuState === 'loop' && menuFrame >= stateData.frames) {
                    menuFrame = 0; // Loop the animation
                } else if (menuState === 'outro' && menuFrame >= stateData.frames) {
                    menuState = 'inactive';
                    startGame();
                }
            }
        }

        function drawMenu() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let currentImage;
            let stateData;

            if (menuState === 'intro') {
                currentImage = images.menuIntro;
                stateData = animationStates.menuIntro;
            } else if (menuState === 'loop') {
                currentImage = images.menuLoop;
                stateData = animationStates.menuLoop;
            } else if (menuState === 'outro') {
                currentImage = images.menuOutro;
                stateData = animationStates.menuOutro;
            }

            if (currentImage && currentImage.complete && currentImage.naturalWidth > 0) {
                const columns = stateData.columns;
                const frameX = menuFrame % columns;
                const frameY = Math.floor(menuFrame / columns);
                const sourceX = frameX * stateData.spriteWidth;
                const sourceY = frameY * stateData.spriteHeight;
                ctx.drawImage(currentImage, sourceX, sourceY, stateData.spriteWidth, stateData.spriteHeight, 0, 0, canvas.width, canvas.height);
            }
        }

        function startGame() {
            gameStarted = true;
            sounds.start.play();
            sounds.roll.play();
            sounds.track.play();
            effectsArray.push(new RunCloud());
            lastTime = performance.now();
            gameLoop(lastTime);
        }

        function menuLoop(currentTime) {
            if (!lastTime) lastTime = currentTime;
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            updateMenu(deltaTime);
            drawMenu();
            
            if (menuState !== 'inactive') {
                requestAnimationFrame(menuLoop);
            }
        }

        // --- Main Game Loop ---
        function gameLoop(currentTime) { /* ... Full Function Logic ... */ }
        
        function initialDraw() {
            if (assetsLoaded < totalAssets) {
                ctx.fillStyle = 'black';
                ctx.font = '20px "Segoe UI"';
                ctx.textAlign = 'center';
                ctx.fillText(`Loading... ${Math.round((assetsLoaded / totalAssets) * 100)}%`, canvas.width / 2, canvas.height / 2);
                setTimeout(initialDraw, 50);
                return;
            }
            lastTime = performance.now();
            menuLoop(lastTime);
        }

        preloadAssets();
        initialDraw();

    </script>
</body>
</html>
